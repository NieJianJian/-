## 代理模式

代理模式也称为委托模式。现实生活类似场景有代购、打官司等。

现实中代购人员完成用户的一些购物需求，并不需要用户自己去买，全程都是代购人员去操作。但是代购人员也必须获得用的授权，才能代表用户去操作。

**1.定义：为其他对象提供一种代理以控制对这个对象的访问称为代理模式。**

**2.代理模式分类**

* 静态代理：在代码运行前就已经存在了代理类的class编译文件。
* 动态代理：在代码运行时通过反射来动态生成代理类的对象，生成类字节码，加载到JVM中。

**3.代理模式结构图**

![](https://github.com/NieJianJian/AndroidNotes/blob/master/Picture/proxypattern.jpg)

如图所示，在代理模式中有如下角色：

* **Subject**：抽象主题类，声明真实主题与代理的共同接口方法。
* **ReadSubject**：真实主题类，定义了代理所表示的集体对象，客户端通过代理类简介调用真实主题类的方法。
* **Proxy**：代理类，持有对真实主题类的引用，在其所实现的接口方法中调用真实主题类中响应的接口方法。
* **Client**：客户端类。

#### 1.静态代理

```java
public class ProxyTest {

    public static void main(String[] args) {
        // 创建真实用户对象
        IShop shop = new BuyUser();
        // 创建代购对象，然后将真实用户传入
        IShop shopProxy = new BuyProxy(shop);
        shopProxy.onBuy();
    }
}

/**
 * 抽象主题类，声明真实主题和代理的共同接口方法
 */
interface IShop {
    void onBuy();
}

/**
 * 真实主题类，声明真正需要购买东西的用户，实现onBuy()方法。
 */
class BuyUser implements IShop {
    @Override
    public void onBuy() {
        System.out.println("buy something...");
    }
}

/**
 * 代理类，需要持有被代理者，并在onBuy()中调用被代理者的onBuy()方法。
 */
class BuyProxy implements IShop {
    private IShop mIShop;
    public BuyProxy(IShop shop) {
        this.mIShop = shop;
    }
    @Override
    public void onBuy() {
        mIShop.onBuy();
    }
}
```

代理类包含了真实主题类（被代理者），最终调用的都是真实主题类（被代理者）实现的方法。

