## 第2章 Java并发机制的底层实现

Java代码编译成Java字节码 ——> 字节码被类加载器加载到JVM里 ——> JVM执行字节码 ——> 转化为汇编指令在CPU上执行。

Java中所使用的并发机制依赖于JVM的实现和CPU指令。

### 1. volatile的应用

volatile是轻量级的synchronized。在多处理器中保证了共享变量的"可见性"。

它比synchronized的使用和执行成本低，因为它不会引起线程上下文切换和调度。

#### 1.1 volatile的定义与实现原理

**定义**：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排它锁单独获得这个变量。

如果一个字段被声明为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。

>> **内存屏障**(memory barriers)：是一组处理器指令，用于实现对内存操作的**顺序限制**
>
>> **缓冲行**(cache line)：CPU高速缓存中可以分配的最小存储单位。处理器填写缓存行时会加载整个缓存行，现代CPU需要执行几百次CPU指令
>
>> **原子操作**(atomic operations)：不可中断的一个或一系列操作
>
>> **缓冲行填充**(cache line fill)：当处理器识别到从内存中读取操作数是可缓存的，处理器会读取整个高速缓存行到适当的缓存（L1，L2，L3的或所有）
>
>> **缓存命中**(cache hit)：如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是内存读取
>
>> **写命中**(write hit)：当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是歇会到内存。
>
>> **写缺失**(write misses the cache)：一个有效的缓存行被写入到不存在的内存区域。

#### 1.2 volatile如何保证可见性

Java代码如下

```
instance = new singleton(); // instance是volatile变量
```

转成汇编代码如下：

```
0x01a3de1d: movb $0x0,0x1104800(%esi);0x01a3de24: lock addl $0x0, (%esp);
```

有volatile变量修饰的共享变量进行写操作时，会有**lock**，Lock前缀的指令在多核处理器下会引发两件事情：

1. 将当前处理器的缓存行的数据写回到系统内存
2. 这个写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效。

**Q**：为了提高处理速度，处理器使用缓存，但完全**不知何时会写到内存**。

**A**：对声明volatile的变量进行写操作，JVM就会向处理器发送一条lock前缀指令，将这个变量所在缓存行数据写回到系统内存。

**Q**：就算写回到祝内存，其他处理器缓存的值仍然是旧的，再计算就会有问题

**A**：在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态，当处理器对这个数据进行修改时，会重新从系统内存中把数据读到处理器缓存里。

volatile的两条实现规则。

1. **Lock前缀指令会引起处理器缓存回写到内存**。

   Lock前缀指令导致在执行指令期间，声言处理器的`LOCK#`信号。多处理器环境中，`LOCK#`信号确保在声言该信号期间，处理器可以**独享任何共享内存**（因为它会锁住总线，导致其他CPU不能访问总想，不能访问总线就意味着不能访问系统内存）。最近的处理器中，`LOCK#`信号一般不锁总线，而是**锁缓存**，因为锁总线开销大。

   如果访问的内存区域已经缓存到处理器内部，则不会声言`LOCK#`信号。而是锁住这块内存区域的缓存并回写到内存，并使用缓存一致性机制来确保修改的原子性，此操作称为**缓存锁定**。**缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据**。

2. **一个处理器的缓存回写到内存会导致其他处理器的缓存无效**。

   如果通过嗅探一个处理器来监测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同内存地址时，强制执行缓存行填充。

***

### 2. synchronized 的实现原理与应用

Java中的每一个对象都可以作为锁。

* 对于普通的同步方法，锁的是当前实例对象。
* 对于静态同步方法，锁的时当前类的Class对象。
* 对于同步方法块，锁是Synchronized括号里配置的对象。

Synchronized在JVM中的实现原理：JVM基于进入和瑞出Monitor对象来实现方法同步和代码块同步。

* 代码块同步时使用monitorenter和monitorexit指令实现的
* 方法同步是使用另外一种方式实现的。但方法的同步同样可以使用这个两个指令来实现。

**monitor原理**：monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。**任何对象都有一个monitor与之关联**，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象锁对应的monitor的所有权，即尝试获取对象的锁。

#### 2.1 对象头

synchronized用的锁是存在Java对象头里的。（32位虚拟机中，1字宽为4字节，即32bit）

* 对象是数组类型，虚拟机用3个字宽存储对象头
* 如果是非数组类型，用2个字宽存储对象头

1. Java对象头的长度

   |   长度    |          内容          |               说明               |
   | :-------: | :--------------------: | :------------------------------: |
   | 32/64 bit |       Mark Word        |   存储对象的hashCode或锁信息等   |
   | 32/64 bit | Class Metadata Address |     存储到对象类型数据的指针     |
   | 32/64 bit |      Array Length      | 数组的长度（如果当前对象是数组） |

2. Mark Word的默认存储结构

   |  锁状态  |     25bit      |     4bit     | 1bit是否是偏向锁 | 2bit锁标志位 |
   | :------: | :------------: | :----------: | :--------------: | :----------: |
   | 无锁状态 | 对象的hashCode | 对象分代年龄 |        0         |      01      |

3. Mark Word里存储的数据会随着锁标志位的变化而变化

   <table>
     	<tr align="center">
         	<td rowspan="2">锁状态</td>
         	<td colspan="2">25bit</td>
         	<td rowspan="2">4bit</td>
         	<td>1bit</td>
         	<td>2bit</td>
       </tr>
     	<tr align="center">
         	<td>23bit</td>
        		<td>2bit</td>
         	<td>是否是偏向锁</td>
         	<td>锁标志位</td>
       </tr>
     	<tr align="center">
         	<td>轻量级锁</td>
         	<td colspan="4">指向栈中锁记录的指针</td>
         	<td>00</td>
       </tr>
     	<tr align="center">
         	<td>重量级锁</td>
         	<td colspan="4">指向互斥量（重量级锁）的指针</td>
         	<td>10</td>
       </tr>
     	<tr align="center">
         	<td>GC标记</td>
         	<td colspan="4">空</td>
         	<td>11</td>
       </tr>
     	<tr align="center">
         	<td>偏向锁</td>
         	<td>线程ID</td>
         	<td>Epoch</td>
         	<td>对象分代年龄</td>
         	<td>1</td>
         	<td>11</td>
       </tr>
   </table>

   在64位虚拟机下，Mark Word是64bit大小的，存储结构表如下：

   <table>
     	<tr align="center">
         	<td rowspan="2">锁状态</td>
         	<td>25bit</td>
         	<td>31bit</td>
         	<td>1bit</td>
         	<td>4bit</td>
         	<td>1bit</td>
         	<td>2bit</td>
       </tr>
     	<tr align="center">
         	<td></td>
        		<td></td>
         	<td>cms_free</td>
         	<td>分代年龄</td>
         	<td>偏向锁</td>
         	<td>锁标志位</td>
       </tr>
     	<tr align="center">
         	<td>无锁</td>
         	<td>unused</td>
         	<td>hashCode</td>
         	<td></td>
         	<td></td>
         	<td>0</td>
         	<td>01</td>
       </tr>
     	<tr align="center">
         	<td>偏向锁</td>
         	<td colspan="2">ThreadID(54bit) Epoch(2bit)</td>
         	<td></td>
         	<td></td>
         	<td>1</td>
         	<td>01</td>
       </tr>
   </table>

#### 2.2 锁的升级与对比

锁的级别从低到高：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。

锁可以升级但不能降级。

1. **偏向锁**

   **原因**：大多数情况下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获得，为了让线程获取锁的代驾更低引入偏向锁。

   **原理**：

   * 线程访问同步块获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID；
   * 以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要简单测试对象头的Mark Word里是否存储着指向当前线程的偏向锁。
     * 测试成功：表示线程已经获得了锁
     * 测试失败：需要再测试一下Mark Word中偏向锁的标识是否设置成1（标识当前是偏向锁）
       * 如果没有：使用CAS竞争锁
       * 如果有：尝试使用CAS将对象头的偏向锁指向当前线程。

   **偏向锁的撤销**：使用一种等到竞争出现才释放锁的机制

   * 撤销需要等待全局安全点（这个点没有正在执行的字节码）
   * 首先暂停拥有偏向锁的线程
   * 然后检查持有偏向锁的线程是否活着
     * 如果线程不处于活动状态，则将对象头设置成无锁状态。
     * 如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象对象不适合作为偏向锁，最后唤醒暂停的线程

2. **轻量级锁**

   **加锁**：线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换位指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

   **解锁**：使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前所存在竞争，锁就会膨胀成重量级锁。

3. **锁的优缺点**

   | 锁       | 优点                                                         | 缺点                                           | 适用场景                           |
   | -------- | ------------------------------------------------------------ | ---------------------------------------------- | ---------------------------------- |
   | 偏向锁   | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销的消耗 | 适用于只有一个线程访问同步块的场景 |
   | 轻量级锁 | 竞争的线程不会阻塞，提高了程序的响应速度                     | 如果始终得不到锁竞争的线程，使用自旋会消耗CPU  | 追求响应速度，同步块执行速度非常快 |
   | 重量级锁 | 线程竞争不使用自旋，不会消耗CPU                              | 线程阻塞，相应时间缓慢                         | 追求吞吐量，同步块执行速度较快     |

***

### 3. 原子操作的实现原理

CPU术语定义:

> > 缓存行(Cache line)：缓存最小的操作单位
>
> >比较并交换(compare and swap)：CAS操作需要输入两个值，一个旧值（其他操作前的值）和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。
>
> > CPU流水线(CPU pipeline)：CPU流水线的工作方式就像工业生产上的装配流水线，在CPU中由5~6个不同的功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5~6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提高CPU的运算速度。
>
> > 内存顺序冲突(Memory order violation)：内存顺序冲突一般是由假共享引起的，假共享是指多个CPU同时修改一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线。

#### 3.1 处理器如何实现原子操作

处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存中读取或者写入一个字节时原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。

单处理器可以保证操作是原子的，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。

1. 使用总线锁保证原子性

   如多处理器执行代码`i++`，想要保证读写共享变量操作是原子的，就需要使用总线锁。

   总线锁就是使用处理器提供一个`LOCK#`信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。

2. 使用缓存锁保证原子性

   总线锁定把CPU和内存之间的通信锁住了，导致其他处理器不能操作其他内存地址的数据，所以总线开销比较大。目前处理器在某些场合下使用缓存锁定代替总线锁定来进行优化。

   **缓存锁定**：是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言`LOCK#`信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性会阻止同时修改由两个以上处理器缓存的内存区域，当其他处理器回写到已被锁定的缓存行的数据时，会使缓存行无效。

   有两种情况下处理器不会使用缓存锁定：

   * 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定。
   * 有些处理器不支持缓存锁定。

   针对以上两个机制，我们通过 Intel 处理器提供的很多Lock前缀的指令来实现。如位测试和修改指令：BTS、BTR、BTC；交换指令XADD、CMPXCHG，以及其他一些操作数和逻辑指令（如ADD、OR）等，被这些指令操作的内存区域就会加锁，导致其他处理器不能同时访问它。

#### 3.2 Java如何实现原子操作

在Java中通过锁和循环CAS的方式来实现原子操作

1. 使用循环CAS实现原子操作

   JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。

   自旋CAS是循环进行CAS操作直到成功为止。

   JDK的并发包提供了一些类来支持原子操作，如AmoticBoolean、AtomicInteger、AtomicLong等。

   LinkedTransferQueue类的Xfer方法使用了自旋CAS的方式来实现原子操作。

2. CAS实现原子操作的三大问题

   * **ABA问题**

     解决思路：使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A -> B -> A就变成了 1A -> 2B -> 3A。JDK的Atomic包提供了一个类AtomicStampedReference来解决ABA的问题。这个类的`compareAndSet`方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

     ```java
     public boolean weakCompareAndSet(V   expectedReference,   // 预期引用
                                      V   newReference,				// 更新后的引用
                                      int expectedStamp,				// 预期标志
                                      int newStamp) {					// 更新后的标志
     ```

   * **循环时间长开销大**

     自旋长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行指令，是CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二，它可以避免在退出循环的时候因内存顺序冲突而引起CPU流水线被清空，从而提高CPU的执行效率。

   * **只能保证一个共享变量的原子操作**

     当对一个共享变量执行操作时，可以使用循环CAS来保证原子操作。

     但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这时候就可以使用锁。

     还有一个取巧的方法，就是把多个共享变量合并成一个共享变量来操作。

     AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。

3. 使用锁机制实现原子操作

   除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想要进入同步块的时候使用循环CAS的方式获取锁，当它退出同步块的时候使用循环CAS释放锁。

