## 第12章 Java内存模型与线程

　　由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代设计算系统都不得不加入一层读写速度尽可能接近处理器运算速度的高级缓存来做为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存中，这样处理器就无需等待缓慢的内存读写了。

　　基于高速缓存的存储交互解决了处理器和内存的速度矛盾，但是带来了新的问题：**缓存一致性**。

***

### 1 Java内存模型

### 1.1 主内存与工作内存

　　Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。

　　Java内存模型规定了所有变量都存储在**主内存**，每条线程还有自己的**工作内存**。线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存的变量。线程间变量值的传递需要通过主内存来完成。线程、主内存、工作内存交互关系如下图：

![](https://raw.githubusercontent.com/NieJianJian/AndroidNotes/master/Picture/memorymodel.jpg)

　　这里的主内存、工作内存和Java内存区域的Java堆、栈、方法区等不是一个层次的内存划分。如果非要对应的化，从变量、主内存、工作内存的定义来看，主内存主要对应Java堆中的对象实例数据部分（Java堆除了实例数据，还是对象的其他信息），而工作内存对应虚拟机栈中的部分区域。

### 1.2 内存间交互操作

　　Java内存模型定义了以下8中操作来完成变量在主内存和工作内存之间的交互，虚拟机实现时必须保证下面的每一种操作都是原子的、不可再分的。

* **lock**（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
* **unlock**（解锁）：作用于主内存变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
* **read**（读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
* **load**（载入）：作用于工作内存变量，它把read操作从主内存中得到变量放入工作内存变量副本中。
* **use**（使用）：作用于工作内存，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
* **assign**（赋值）：作用于工作内存变量。它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
* **store**（存储）：作用于工作内存变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
* **write**（写入）：作用于主内存变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

### 1.3 对于volatile型变量的特殊规则

　　[Volatile](https://github.com/NieJianJian/AndroidNotes/blob/master/ReadingNotes/Book1/Volatile.md)

### 1.4 对于long和double型变量的特殊规则

　　Java内存模型要求lock、unlock、read、load、assign、use、store、write这8个操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作分为两次32位的操作来执行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这个4个操作的原子性，这就是所谓的**long和double的非原子协定**。

　　不过目前大部分虚拟机都选择把64位数据的读写作为原子操作来对待，所以在编写代码是**一般不需要把用用到的long和double变量专门声明为volatile**。

#### 1.5 原子性、可见性与有序性

* **原子性**：由Java内存模型来直接保证原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为*基本数据类型的访问读写是具备原子性的（long和double除外）*。

  　　如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和moniterexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，所以**在synchronized块之间的操作也具备原子性**。

* **可见性**：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。
  * volatile保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。
  * synchronized同步块的可见性是由"对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）"这条规则获得的。
  * final关键字的可见性是指：被final修饰的字符在构造器中一旦初始化完成，并且构造器没有把"this"引用传递出去（this引用逃逸是一件很危险的事，其他线程可能通过这个引用访问到"初始化了一半"的对象），那在其他线程中就能看见final字段的值。

* **有序性**：如果在本线程内观察，所有的操作都是有序的（指"线程内表现为串行的语义"）；如果在一个线程中观察另一个线程，所有操作都是无序的（指"指令重排序"现象和"工作内存与主内存同步延迟"现象）。
  * volatile关键字本身就包含了禁止指令重排序的语义
  * synchronized则是由"一个变量在同一时刻只允许一条线程对其进行lock操作"这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行地进入。

#### 1.6 先行发生原则

　　下面是Java内存模型中一些"天然的"先行发生关系（只有这些）：

* **程序次序规则**：在一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确的说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
* **管程锁定规则**：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调是同一个锁，而"后面"是指时间上的先后顺序。
* **volatile变量规则**：对一个volatle变量的写操作先行发生于后面对这个变量的读操作，这里的"后面"同样是指时间上的先后顺序。
* **线程启动规则**：Thread对象的start()方法先行于此线程的每一个动作。
* **线程终止规则**：线程的所有操作都先行于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止。
* **线程中断规则**：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupt()方法检测到是否有中断发生。
* **对象终结规则**：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
* **传递性**：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。

　　时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候，不要收到时间顺序的干扰，一切以先行发生原则为准。

