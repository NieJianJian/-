## 第8章 虚拟机字节码执行引擎

　　在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有**解释执行**（通过解释器执行）和**编译执行**（通过即时编译器产生本地代码执行）两种选择。

***

### 1. 运行时栈帧结构

　　**栈帧**用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。

　　栈帧包括局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性中。

　　一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为**当前栈帧**，与这个栈帧相关联的方法称为**当前方法**。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作。栈帧结构图如下：

![](https://raw.githubusercontent.com/NieJianJian/AndroidNotes/master/Picture/stackframe.png)

### 1.1 局部变量表

　　局部变量表是一组变量值存储空间，用于存放**方法参数**和**方法内部定义的局部变量**。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量的最大容量。局部变量表的容量以**变量槽**（Slot）为最小单位，Slot所占用的内存空间大小并未明确指明，只是每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据。

　　由于局部变量表建立在线程的堆栈上，是线程私有，无论读写两个连续的Slot是否为原子操作，都不会引起数据安全问题。（Java中64位的数据类型只有long和double）

　　局部变量表的Slot可以重用，这样设计除了节省栈空间，还有副作用，如影响系统的垃圾收集行为。

```
// 代码1：局部变量表Slot复用对垃圾收集的影响之一
public static void main(String[] args) {
    byte[] placeholder = new byte[64 * 1024 * 1024];
    System.gc(); // 未回收placeholder所占内存
}

// 代码2：局部变量表Slot复用对垃圾收集的影响之二
public static void main(String[] args) {
    {
        byte[] placeholder = new byte[64 * 1024 * 1024];
    }
    System.gc(); // 未回收placeholder所占内存
}

// 代码3：局部变量表Slot复用对垃圾收集的影响之三
public static void main(String[] args) {
    {
        byte[] placeholder = new byte[64 * 1024 * 1024];
    }
    int a = 0;
    System.gc(); // 回收placeholder所占内存
}
```

placeholder能否被**回收的根本原因**是：局部变量表中的Slot是否还存有关于placeholder数组对象的引用。

* 代码1没有回收placeholder所占内存，因为在执行System.gc()时，变量placeholder还处于作用域之内，虚拟机自燃不敢回收placeholder内存。
* 代码2加入花括号，placeholder作用域被限制在花括号内，代码虽然离开了placeholder的作用域，但此之后，没有任何局部变量表的读写操作，placeholder原本占用的Slot并未被复用，所以做为GC Roots一部分的局部变量表仍然保持着对它的关联。
* 如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值（用来代替那句int a = 0，把变量对应的局部变量表Slot清空）便不见得是一个绝对不无意义的操作（书《Practical Java》中把"不使用的对象手动赋值为null"作为一条推荐的编码规则）。赋null值的操作在经过JIT编译优化后就会被消除掉，此时便没有意义。

**注：局部变量定义了但没有赋初始值是不能使用的。**

### 1.2 操作数栈

　　操作数栈也称为操作栈，后入先出。操作数栈的最大深度为Code属性的max_stacks数据项的值。

　　当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中、会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。例如，在做算数运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。

　　**eg**：整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈。

### 1.3 动态连接

　　每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程的动态连接。Class文件的常量池中存在大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为**静态解析**。另外一部分将在每一次运行期间转化为直接引用，这部分称为**动态连接**。

### 1.4 方法返回地址

当一个方法开始执行后，只有两种方式可以退出这个方法：

* **正常完成出口**：执行引擎遇到任意一个方法返回的字节码指令。
* **异常完成出口**：方法执行过程遇到异常，并且这个异常没有在方法体内得到处理。

方法退出的过程实际上是把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调用PC计数器的值以指向方法调用指令后面的一条指令等。

***

### 2. 方法调用

　　方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本。Class文件的编译过程中不包含传统编译中的链接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（直接引用）。

### 2.1 解析

　　所有方法调用中的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期时不可改变的。这类方法的调用称为**解析**。

　　Java虚拟机里面提供了5条调用字节指令，如下：

* **invokestatic**：调用静态方法
* **invokevirtual**：调用所有虚方法
* **invokespecial**：调用实例构造器< init>方法、私有方法和父类方法
* **invokeinterface**：调用接口方法，会在运行时再确定一个实现此接口的对象
* **invokedynamic**：现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。

　　只要能被invokestatic和invokespecial指令调用的方法，都能在解析阶段中确定位移调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用，这些方法称为**非虚方法**，与之相反，其他的方法称为**虚方法**（除去final方法）。final方法虽然使用invokevirtual指令来调用，但是由于无法覆盖，所以**final方法是一种非虚方法**。

### 2.2 分派







　　