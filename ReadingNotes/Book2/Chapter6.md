## 第6章 其他优秀的热修复方案

### 1 Dexposed浅析

### 1.1 前言

* Xposed要劫持Zygote进程来hook系统方法，所以需要root权限。
* Dexposed是自己hook自己的应用，不需要root权限。

### 1.2 Java函数调用原理

　　Dalvik内部如果需要调用某个函数，则会调用`dvmCallMethod`函数，之后进行一系列的栈操作。如果一个方法是Java方法，其逻辑由`dvmInterpret`完成。如果一个方法是native方法，那么Dalvik内部会跳转到`nativeFunc`函数指针处执行，这个函数指针正是Dexposed方案hook方法的关键所在。

### 1.3 Dexposed用法

Dexposed对于某个函数而言，有三个hook点可供选择：函数执行前注入，函数执行后注入，替换函数执行的代码段。典型应用场景如下：

* AOP编程
* 插桩（例如测试，性能检测等）
* 在线热更新，修复严重的，紧急的或者安全性的BUG
* SDK hooking以提供更好的开发体验

***

### 2 AndFix探索历程

### 2.1 补丁包的加载运行

Android中，我们开发应用主要用的是Java语言，程序是运行在Dalvik或者Art虚拟机上，它有几个特点：

* 托管代码的方式，如果站在虚拟机的层面，是有权限去修改虚拟机字节码所占的内存的。
* 对于当前进程，可以很轻松的挂载动态的可执行库，无论是dyld，还是Java的load。
* 可以比较方便的开辟出一块新的字节码的内存，并设为可执行的权限，通过ClassLoader动态加载一个类就搞定了。
* 程序第一次加载前一般会对字节码做一次优化，对于Dalvik是dexopt，对于Art是dex2oat。

一般虚拟机在运行的时候，加载字节码之后就会根据字节码构造相应的语法结构。如果我们把内存中Method对应的内存结构做一下修改，把其中的指令语句的内存offset换成其他指令语句的地址是不是就可以了？

### 2.2 方法替换

　　在运行时对方法做些指令替换，以达到我们补丁包加载执行的目的。我们巧妙地利用现有的机制，直接加载事先准备好的字节码，把它们的相应数据结构做下替换。简单的说就是在运行的时候，用新加载的一个方法来替换掉现有的方法，也就是方法替换。因为仅仅是方法替换，所以对外的接口需要保持一致，也就是说需要替换和被替换的两个方法的签名是一致的，包括方法名、入参、出参、以及相应的类型。

存在一些问题，主要是verify的问题：

* 类的加载问题。Java的类的加载模型是双亲委派的。我们的方案中，直接来加载事先准备好的字节码，但是它所依赖的类还在原来的ClassLoader，所以要么用来加载的这个ClassLoader，它的ParentClassLoader是依赖的类的ClassLoader，要么就需要打破这个双亲委派模型。如果是前者，对于类名也有要求，因为在一个类加载的链路上，一个类名只能唯一的对应到一个类，不可以多个类的名字相同，否则就要看加载顺序了。另外对于新加在的类的ClassLoader我们也需要改成原类型对应的ClassLoader，否则在方法中所依赖的类的加载也将成为一个问题。
* 对于方法所在类的校验。对于实例方法，它的invoke第一个参数就是实例本身，但是实例的类型却不是之前方法所在的类的类型了，它的类型是类加载的时候所在的类的类型。所以我们需要去想办法绕过这个限制，有一种做法就是把新加在的类的类型作为原类的子类型，不过这种办法需要去填的坑一定不少；另一个简单的办法就是把替换过来的方法的类指向原来的类，我们才去的方式是后者，当然也有一些坑需要去填。
* 对于方法调用的权限校验。private方法类外部无法调用，直接把修饰改为public。

　　实施上，就是创建一个以程序当前ClassLoader为ParentClassLoader的ClassLoader来加载补丁类，补丁类不与原程序的类同名；再在虚拟机层面挂载方法替换的动态库，我么采用的就是简单的Java来load；然后通过JNI来做虚拟机上的操作，比如把类或者方法转成内存地址，并对相应的抽象语法树层面的数据结构做操作，把对应Method的结构做相应的修改及替换。最终达到在运行时作方法替换的目的。

### 2.3 补丁包的制作

* 补丁包一般是由开发者开发出来的，所以我们一定要做到开发者友好。
* 补丁包要足够小，这样不管是对于用户流量，还是对于实时触达都是大有裨益。

AndFix从代码逻辑层面来做diff。对APK文件中的字节码做分析，构造出抽象语法树，然后逐个做diss，发现其中有不一样的地方就该对方法做个标记，然后在最后把所有不一样的方法的类重新编译成一个字节码文件，扩展名为apatch。期间这个工具还做了一些其他工作。

* **对有变更的方法做标记**。在方法上面加一个运行时注解，当补丁包被加载的时候，会遍历所有包含该注解的方法，调用方法替换的动态执行库执行方法替换。主要目的有两个：一个是在运行时对方法做替换能够做到可控，另一个是性能，加快替换速度，把不需要替换的方法甄别出来。
* **对类名做更改**。类不能同名，所以打包需要修改类名以确保运行的时候ClassLoader能正确的加载。改名逻辑就是在原类名之后加个后缀，后缀是一个固定的魔法串再加上时间戳。时间戳是为了当做版本号。补丁包永远向前走，不回滚，要回滚就带上新的时间戳重新发布。
* **对补丁包签名**。确保补丁包不会被篡改。

补丁包制作需要去解决的一些其他问题：

* **对于混淆的支持**。对于使用proguard来做代码混淆的，这个比较简单，因为proguard本身提供保存字典的，并可以利用之前保存的字典来做新版本的代码混淆。开发者需要做的是保留每个版本的mApping文件，不过一般应该都有保存，否则出现问题了怎么去做符号解析来辅助问题排查呢。构建新版本使用该mApping文件做输入，以此类推。
* **对于加固的支持**。目前加固方式琳琅满目，原理也各不相同，不过总可以保留加固之前的原始包吧，制作补丁包的时候就是用原始包来做输入。

### 2.4 补丁包的安全下发

* **对补丁包签名**。目的是为了防篡改，我们会在程序中去取公钥，在补丁包每次加载的时候做验证，原理上其实就是类似apk的签名验证。
* **对优化后的字节码文件做摘要**。目的是防止对优化后的文件做篡改，就是为应对"寄生兽"的漏洞，对于这块的处理其实很简单，只是简单的做下MD5摘要并对摘要存储，之后每次加载的时候都去做这个验证。

***

### 3 Amigo核心解读

### 3.1 feature及实现原理

　　Amigo的核心思想是借用App的运行时，偷梁换柱**替换整个App运行的代码**，包括dex、so、assets。Amigo接收的patch其实是一个可独立安装运行的APK，替换的是整个运行时代码。所以不存在Dalvok和ART下类似pre-verified问题，也就不需要像其他方案一样插桩。

***

### 4 腾讯系热修复方案简介

　　`dvmResolveClass`函数的主要功能是用来加载一个类之前解析这类的详细信息。对于预先插入dex方案，很可能在这个函数中发生`Class resolved by unexpected DEX`的问题，也就是`pre-verify`异常。

* QQ空间超级补丁。把`CLASS_ISPREVERIFIED`标识去除，让每个类都引用一个不在本dex的类。这个方案对每个类插入额外代码，代码臃肿，而且由于没有`CLASS_ISPREVERIFIED`标识，会使得Resolve类的时间变长。
* QFix。思路是先执行`dvmResolveClass`函数，并且传入参数`fromUnverifiedConstant`为false，这样就可以跳过`pre-verify`检查的逻辑判断，直接执行`dvmDexSetResolveClass`，后面再次进入dvmResolveClass就不会引发问题。这个方案的致命问题是在原有已经存在的类中新增public/protect/default方法，条件被严重局限。

* Tinker采用的方案是基于补丁和原APK中的dex包，完整合成全量dex，并且抛弃原生机制的dex和采用这个新合成的dex，这样就可以避免补丁类和旧类所属DEX不一致的问题。最大的亮点是极致的dex补丁差量操作。精细合成的问题在于性能损耗，由于粒度太细，生成补丁要花费时间，手机端合成也相当消耗性能。

在Art运行时环境下，不存在pre-verify问题。直接插入补丁dex是可以正常修复的。不过在7.0之后JIT机制，超级补丁和QFix无法解决Android JIT机制导致的旧类的热代码残留问题——加载一个类的时候始终会解析到原有APK的dex中被JIT的旧类，而无法解析到补丁类。