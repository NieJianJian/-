## 第2章 Java内存区域与内存溢出异常

### 1.Java虚拟机运行时数据区

![图：Java虚拟机运行时数据区](https://raw.githubusercontent.com/NieJianJian/AndroidNotes/master/Picture/jvmruntimedata.jpg)

### 1.1 程序计数器

　　**是什么**：看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

　　**Java虚拟机多线程的实现方式**：通过线程轮流切换并分配处理器执行时间的方式实现的。在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都会只执行一条线程的指令。

　　**为什么**：为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，各线程之间计数器互不影响，独立存储，称这类内存区域为"线程私有"的内存。

**计数器的记录内容：**

* 线程执行Java方法，记录的是正在执行的虚拟机字节码指令的地址；
* 线程执行Native方法，值为空。

**注**：此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

### 1.2 Java虚拟机栈

　　**特点**：线程私有，生命周期与线程相同。

　　**栈帧**：每个方法在执行的同时都会创建一个栈帧，存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈种入栈到出栈的过程。

　　**局部变量表**：存放编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，非对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向一条字节码指令的地址）。

　　**注**：long和double类型的长度为64位，占用2个局部变量空间（Slot）。

　　**注**：局部变量表所需内存空间在编译期完全分配，确定大小，方法运行也不会改变。

**规定的异常情况**：

* StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度时抛出。
* OutOfMemoryError：虚拟机动态扩展无法申请到足够的内存时抛出。

### 1.3 本地方法栈

　　虚拟机栈为虚拟机执行Java方法（字节码）服务；本地方法栈为虚拟机执行Native方法服务。

　　**使用**：使用的语言、方式、数据结构无规定，也可将本地方法栈与虚拟机栈合并（如HotSpot）；

　　**规定的异常**：StackOverflowError、OutOfMemoryError。

### 1.4 Java堆

　　**特点**：占用内存最大、线程共享、虚拟机启动时创建、垃圾收集器管理主要区域（称GC堆）、物理内存空间中可不连续（逻辑连续即可）。

　　**唯一目的**：分配对象实例以及数组。*几乎*所有对象是里都在这里分配内存（不绝对）。　　

　　**规定的异常**：堆中无内存分配，无法扩展时抛出OutOfMemoryError。

### 1.5 方法区

　　**特点**：线程共享

　　**使用**：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

　　**规定的异常**：方法区无法满足内存分配时抛出OutOfMemoryError。

### 1.6 运行时常量池

　　**介绍**：属于方法区一部分。

　　**作用**：存放编译期生成的各种字面量和符号引用。

　　除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。Class文件中有类的版本号、字段、方法、接口等描述信息，以及常量池，这部分内容在类加载后进入方法区的运行时常量池。

　　**特点**：并未要求只有编译期产生，运行期间也可将新常量放入方法区运行时常量池，如Sting类intern()方法。

　　**规定的异常**：属于方法区，无法满足内存分配时抛出OutOfMemoryError。

### 1.7 直接内存

　　不属于虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。受本机总内存限制。

　　服务器管理员在配置虚拟机参数是，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。

***

### 2 HotSpot虚拟机

### 2.1 对象的创建

* 1）虚拟机遇到new指令。

* 2）检查指令的参数是否能在常量池中定位到一个类的符号引用。

* 3）检查这个符号引用代表的类是否已被加载、解析和初始化过，若没有，执行类加载过程。

* 4）分配内存（堆上）

  * 对象所需内存的大小在类加载完成后完全确定。

  * 分配方式：

    * 指针碰撞：Java堆内存规整，用过内存放一边，空闲内存放一边，中间用指针做分界点指示器，分配内存时就是将指针向空闲区域挪动和对象大小相等的距离。
    * 空闲列表：Java对内存不规整，虚拟机需维护一个记录内存是否可用的列表，分配时找到足够大的内存分配给对象实例，并更新列表的记录。

    垃圾收集器是否有压缩整理功能 -> Java对是否规整 -> 分配方式的选择

  * 线程安全问题解决方案

    * 对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。
    * 每个线程在Java堆中预先分配一小块内存，成为本地线程分配缓冲（TLAB），线程分配内存，在TLAB上操作，TLAB用完，分配新的TLAB，此时才需要同步锁定。

* 5）将分配到的内存空间都初始化为零值（不包括对象头）。

  这一步保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。（Java虚拟机不会给局部变量初始化为默认值）

* 6）虚拟机对对象头进行设置。例如这个对象是哪个类的实例、如何能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。

* 7）执行对象< init>方法。从虚拟机来看对象已经产生，Java程序来看对象创建刚刚开始——< init>方法还未执行，所有字段都还为零。执行< init>方法对象才算完全产生出来。

### 2.2 对象的内存布局

对象在内存中存储的布局分为3块区域：

* 对象头（Header）
  * MarkWord：存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别未32bit和64bit。被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，会根据对象的状态复用自己的存储空间。例如，在32位的HotSpot虚拟机中，如果对象处于未锁定的状态下，那么Mark Word的32bit空间中的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，而其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表：
  
    |               存储内容               | 标志位 |        状态        |
    | :----------------------------------: | :----: | :----------------: |
    |       对象哈希码、对象分代年龄       |   01   |       未锁定       |
    |           指向锁记录的指针           |   00   |     轻量级锁定     |
    |          指向重量级锁的指针          |   10   | 膨胀（重量级锁定） |
    |          空，不需要记录信息          |   11   |       GC标记       |
    | 偏向线程ID、偏向时间戳、对象分代年龄 |   01   |       可偏向       |
  
  * KlassPointer：类型指针，即对象指向它的类元数据的指针，虚拟机通过该指针确定这个对象是哪个类的实例。
  
  * 数组长度（**可选**）：如果对象是Java数组，对象头中必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据确定Java对象大小，但是从数组的元数据中无法确定数组的大小。
* 实例数据（Instance Data）：是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论时从父类继承下来的，还是在子类中定义的，都需要记录起来。
* 对齐填充（Padding）：非必然存在。由于HotSpot VM的自动内存管理系统要求对象起始地址必须时8字节的整数倍，也就是对象的大小必须是8字节的整数倍。对象头时8字节的1倍或2倍，当对象实例数据部分没有对齐时，需要通过对齐填充来补全。

### 2.3 对象的访问定位

　　Java是通过栈上的reference数据来操作堆上的具体对象。但是reference类型只是虚拟机规范中规定指向一个对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。主流访问方式有使用句柄和直接指针两种。

* 句柄：Java堆中将会划分处一块内存做为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了包含了对象实例数据与类型数据各自的具体地址信息。

  ![图：通过句柄访问对象](https://raw.githubusercontent.com/NieJianJian/AndroidNotes/master/Picture/handleaccessproject.png)

  * **好处**：reference中存储的是稳定的句柄地址，对象被移动时（垃圾收集时移动对象是非常普遍的行为）只会改变句柄中的实例数据指针，reference本身不需要修改。

* 直接指针：Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。

  ![图：通过直接指针访问对象](https://raw.githubusercontent.com/NieJianJian/AndroidNotes/master/Picture/directpointeraccessoobject.png)

  * **好处**：速度快，节省一次指针定位的时间开销。

### 3 实战：OutOfMemoryError异常

