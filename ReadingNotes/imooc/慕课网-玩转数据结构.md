[示例代码](https://github.com/liuyubobobo/Play-with-Data-Structures)



## 第一章 欢迎学习

* 数据结构分类

  * 线性结构

    数组；栈；队列；链表；哈希表...

  * 树结构

    堆；二分搜索树；二叉树；红黑树；并查集；Trie；哈夫曼树；AVL；线段树...

  * 图结构

    邻接矩阵；邻接表

## 第二章 不要小瞧数组

* O(1)，O(n)，O(lgn)，O(nlogn)，O(n^2)

* 大O描述的是算法的运行时间和输入数据之间的关系。

  ```java
  public static int sum(int[] nums) {
      int sum = 0;
      for (int num : nums) sum += num;
      return sum;
  }
  ```

  上述代码的时间复杂度是`O(n)`。n是数组`nums`中的元素个数。也就是说代码的时间复杂度，是和n的个数成线性关系的。

* 为什么要用大O，叫做O(n)？

  忽略常数。实际时间为 T = c1 * n + c2。

  * T = 2 * n + 2                      o(n)
  * T = 2000 * n + 10000       o(n)
  * T = 1 * n * n  + 0               o(n ^ 2)

  第三个例子的时间复杂度是O(n ^ 2)，第二个例子是O(n)，但并不代表第三个例子就一定比第二个例子复杂。n的值不同，结果也是不一样的。

  大O描述的是渐进时间复杂度，描述n趋近于无穷的情况。

  O(n)考察的是最坏的情况，也就是最长耗时的情景。

* 均摊复杂度

* 复杂度震荡

## 第三章 栈和队列

* 栈 Stack

  * 相比数组，栈对应的操作是数组的子集
  * 只能从栈顶添加和删除元素
  * 栈是一种后进先出的结构（LIFO）
  * 相关的一些方法：push(E)、pop()、peek()

* 栈的应用

  * 无处不在的Undo操作（撤销）
  * 程序调用的系统栈
  * 括号匹配 - 编译器

* LeetCode —— 有效的括号

  > 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
  >
  > 有效字符串需满足：
  >
  > 左括号必须用相同类型的右括号闭合。
  > 左括号必须以正确的顺序闭合。
  > 注意空字符串可被认为是有效字符串。

  ```java
  public static boolean isValis(String s) {
      Stack<Character> stack = new Stack<>();
      for (char c : s.toCharArray()) {
          if (c == '(' || c == '[' || c == '{') {
              stack.push(c);
          } else {
              if (stack.isEmpty()) return false;
              char top = stack.pop();
              if (c == ')' && top != '(') return false;
              if (c == ']' && top != '[') return false;
              if (c == '}' && top != '{') return false;
          }
      }
      return stack.isEmpty();
  }
  ```

* 队列 Queue

  * 相比数组，队列对应的操作是数组的子集
  * 只能从队尾添加元素，只能从队首取出元素。
  * 先进先出的数据结构（FIFO）
  * 相关的一些方法：enqueue(E)、dequeue()、getFront()

* 数组队列的问题

  * 出队的时间复杂度是O(n)。因为取出index = 0的值，然后将后面的所有元素都向前移动一位。

* 循环队列（解决上述问题）

  * 设置front指向队首元素，tail指向队尾元素。
  * 队列为空时，front == tail。
  * 删除元素时，front++，修改front的指向。这样就不需要移动所有元素了。
  * 当(tail + 1) % c == front时认为队列满（浪费一个元素）。
  * 如果删除元素多，tail = capacity时，计算(tail + 1) % c == front，如果为false，则tail = (tail + 1) % c，网数组为0的地方开始插入元素，直到满足(tail + 1) % c == front。这就是循环队列。
  * 循环队列将普通队列出栈的时间复杂度由O(n)变成了O(1)。

## 第四章 最基础的动态数据结构——链表 LinekdList

* 动态数组、栈、队列 —— 底层依托静态数组；靠resize解决固定容量问题
* 链表 真正的动态数据结构
  * 优点：不需要处理固定容量的问题
  * 缺点：丧失了随机访问的能力

* 数据存储在"节点"（Node）中

  ```java
  class Node {
      E e;
      Node next;
  }
  ```

* 为链表设置**虚拟头结点**，可以减少对index = 0的判断。

* 使用链表实现队列

## 第五章 链表和递归

* LeetCode —— 删除链表的节点

  > 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
  >
  > 返回删除后的链表的头节点。

  ```java
  /**
   * Definition for singly-linked list.
   * public class ListNode {
   *     int val;
   *     ListNode next;
   *     ListNode(int x) { val = x; }
   * }
   */
  class Solution {
      public ListNode deleteNode(ListNode head, int val) {
          while (head != null && head.val == val) {
              // ListNode delNode = head;
              head = head.next;
              // delNode.next = null;
          }
          if (head == null) return null;
  
          ListNode prev = head;
          while (prev.next != null) {
              if (prev.next.val == val) {
                  // ListNode delNode = prev.next;
                  // prev.next = delNode.next;
                  // delNode.next = null;
                  prev.next = prev.next.next;
              } else {
                  prev = prev.next;
              }
          }
          return head;
      }
      
      // 使用头结点
      public ListNode deleteNode(ListNode head, int val) {
          ListNode dummyHead = new ListNode(-1);
          dummyHead.next = head;
          ListNode pre = dummyHead;
          while (pre.next != null) {
              if (pre.next.val == val) {
                  pre.next = pre.next.next;
              } else {
                  pre = pre.next;
              }
          }
          return dummyHead.next;
      }
  }
  ```

* 递归

  * 本质上，将原来的问题，转化为更小的同一问题

  * 举例：数组求和

    ```java
    Sum(arr[0...n-1]) = arr[0] + Sum(arr[1...n-1])
    Sum(arr[1...n-1]) = arr[1] + Sum(arr[2...n-1])
    ...
    ```

    ```java
    public static int sum(int[] arr) {
        return sum(arr, 0);
    }
    
    public static int sum(int[] arr, int l) {
        if (arr.length == l) return 0;
        return arr[l] + sum(arr, l + 1);
    }
    ```

* 链表天然的递归性

  * 近乎和链表相关的所有操作，都可以使用递归来解决

  用递归完成：LeetCode —— 删除链表的节点

  ```java
  public ListNode deleteNode(ListNode head, int val) {
      if (head == null) return null;
      ListNode res = deleteNode(head.next, val);
      if (head.val == val){ // head满足被删除的条件
          return res;
      } else {
          head.next = res;
          return head;
      }
  }
  
  public ListNode deleteNode(ListNode head, int val) {
      if (head == null) return null;
      head.next = deleteNode(head.next, val);
      if (head.val == val){ // head满足被删除的条件
          return head.next;
      } else {
          return head;
      }
  }
  ```

## 第六章 二分搜索树

* 二叉树

  * 和链表一样，动态数据结构

    ```java
    class Node {
        E e;
        Node left;
        Node right;
    }
    ```

  * 二叉树具有唯一根节点

  * 二叉树每个节点最多有两个孩子，每个节点最多有一个父亲。

  * 一个孩子都没有的，称为叶子节点

  * 二叉树具有天然的递归性

    * 每个节点的左子树也是二叉树
    * 每个节点的右子树也是二叉树

  * 二叉树不一定是满的

    * 一个节点也是二叉树
    * 空也可以是一个二叉树

* 二分搜索树 Binary Search Tree

  * 二分搜索树是二叉树

  * 二分搜索树的每个节点的值：

    * 大于其左子树的所有节点的值
    * 小于其右子树的所有节点的值

  * 每一颗子树也是二分搜索树

  * 存储的元素必须有可比较性。

    Java中的话就要求二分搜索树保存的数据类型要实现Comparable接口, 或者使用额外的比较器实现。

* 递归插入数据

  ```java
  public Node add(Node node, E e) {
      if (node == null) {
          size++;
          return new Node(e);
      }
      if (e.compareTo(node.e) < 0) {
          node.left = add(node.left, e);
      } else if (e.compareTo(node.e) > 0) {
          node.right = add(node.right, e);
      }
      return node;
  }
  ```

* 二分搜索树的遍历

  * 前序遍历（根-左-右）

  * 中序遍历（左-根-右）

    中序遍历的结果就是二分搜索树的存储的所有元素排序后的结果

  * 后序遍历（左-右-根）

    * 应用：为二分搜索树释放内存

  * 二分搜索树的编译可以用非递归的方式实现——栈。

  * 深度优先遍历
  * 广度优先遍历（层序遍历）——用队列实现
    * 更快的找到问题的解
    * 常用于算法设计中 - 最短路径

* 二分搜索树删除节点

  * 删除左右都有孩子的节点 d

    * 找到 s = min (d -> right)，s是d的后继。

    * s -> right = delMin(d -> right)

    * s -> left = d.left

    * 删除d，s是新的子树的根。

    上述方法是寻找后继，也可以在左子树中找前驱。

## 第七章 集合和映射 Set and Map

* 集合 Set
  * 不能重放重复元素，每个元素只能放置一次。可以用于去重。
  * 典型应用
    * 网站IP统计
    * 词汇量统计
  * 可以用二分搜索树实现
  * 可以用链表实现（链表不需要具有可比性，这也是线性结构的一个特点）
  * 二分搜索树的效率高于链表

* 集合时间复杂度分析

  | 操作 | 链表 | BST  |  平均   | 最差 |
  | :--: | :--: | :--: | :-----: | :--: |
  |  增  | O(n) | O(h) | O(logn) | O(n) |
  |  查  | O(n) | O(h) | O(logn) | O(n) |
  |  删  | O(n) | O(h) | O(logn) | O(n) |

  h为二分搜索树的高度，n就是二分搜索树的元素个数。

  二分搜索树中 n = 2<sup>0</sup> + 2<sup>1</sup> + 2<sup>2</sup> + ... + 2<sup>h-1</sup> = 2<sup>h</sup> - 1，所以 h = log<sub>2</sub>(n + 1) = O(log<sub>2</sub>n)。

  和线性关系的1n、2n、10n、100n一样，我们不关注前面的倍数，只关注n。

  所以log一样，底数是多少，也不关注，最终定义为O(logn)。

  最差考虑的是元素个数，等于BST的深度，这是一种极端情况（等同于链表）。

  logn和n的差距：

  |           | logn |   n   | 相差倍数  |
  | :-------: | :--: | :---: | :-------: |
  |  n = 16   |  4   |  16   |  相差4倍  |
  | n = 1024  |  10  | 1024  | 相差100倍 |
  | n = 100万 |  20  | 100万 | 相差5万倍 |

* 有序集合和无序集合

  * 有序集合中的元素具有顺序性——基于搜索树的实现
  * 无需集合中的元素没有顺序性——基于哈希表的实现

* 多重集合：集合中的元素可以重复

* 映射 Map

  * 存储（键，值）数据对的数据结构（key，value）

  * 根据键（key），寻找值（value）

  * 可以用二分搜索树实现

    ```java
    class Node {
        K key;
        V value;
        Node left;
        Node right;
    }
    ```

  * 可以用链表实现

    ```java
    class Node {
        K key;
        V value;
        Node next;
    }
    ```

* 映射的时间复杂度和集合的分析一致

* 有序映射和无序映射

  * 有序映射中的元素具有顺序性——基于搜索树的实现
  * 无需映射中的元素没有顺序性——基于哈希表的实现

* 多重映射：映射中的键可以重复

## 第八章 优先队列和堆

* 优先队列

  * 普通队列：先进先出；后进后出。
  * 优先队列：出队顺序和入队顺序无关，和优先级有关。

  |              |  入队   | 出队（拿出最大元素） |
  | :----------: | :-----: | :------------------: |
  | 普通线性结构 |  O(1)   |         O(n)         |
  | 顺序线性结构 |  O(n)   |         O(1)         |
  |      堆      | O(logn) |       O(logn)        |

* 二叉堆 Binary Heap

  堆，本身也是一棵树。

  二叉树来表示一个堆，也就是二叉堆。

  * 二叉堆是一个完全二叉树。
  * **完全二叉树**：把元素顺序排列成树的形状。（一层一层，从左往右存放）
    * 最大堆：堆中某个节点的值总是不大于（小于等于）其父节点的值。（根节点最大）
    * 最小堆：堆中某个节点的值总是不大于（小于等于）其孩子节点的值。（根节点最小）
  * 用数组存储二叉堆
    * parent(i) = (i - 1 ) / 2
    * left child (i) = 2 * i + 1
    * right child (i) = 2 * i + 2

* 堆添加元素 Sift Up

  * 数组实现的基础下，添加到数组的最后。
  * 然后和父节点进行比较，如果大于父节点，则和父节点进行交换
  * 然后继续和上一级父节点进行比较，直到满足条件"堆中的某个节点总是不大于其父节点的值"。

* 取出元素 Sift Down

  * 最大堆，只能取出最大的元素，也就是根节点的元素。
  * 首先，将根节点的元素，也就是数组角标为0的元素取出；
  * 然后将数组最后的元素，放到根节点的位置，此时，依旧满足完全二叉树，但是元素条件不满足了；
  * 然后将此时根节点的元素和它两个孩子去比较，选择两个孩子中最大的元素，进行交换；
  * 然后继续向下判断左右孩子的，直到满足条件"堆中的某个节点总是不大于其父节点的值"。

## 第十二章 平衡树和AVL

* AVL是经典的平衡二叉树

* **平衡二叉树**：整个二叉树最大的叶子节点和最小的叶子节点深度值相差不会大于1。

  * 对于任意一个节点，左子树和右子树的高度差不能超过1
  * 平衡二叉树的高度和节点数量之间的关系也是O(logn)的
  * 标注节点的高度（叶子高度为1，依次向根节点计算，非叶子节点取左右子树的高度最大值+1）
  * 计算平衡因子（左子树高度 - 右子树高度）

* 如何判断一个二叉树是不是二分搜索树

  * 二分搜索树特点：中序遍历的结果是按顺序排列的
  * 首先对二叉树进行中序遍历，然后依次将结果放入一个List中。
  * 然后对结果List进行遍历，调用compareTo()方法对前后元素进行比较。
  * 最终判断是不是二分搜索树。

* 平衡二叉树实现原理

  * 维护时机

    添加节点后，沿着节点向上回溯维护平衡性，判断平衡因子的值。

  * LL、RR、LR、RL

  * LL：采取左旋转

    ```java
    // 对节点y进行向左旋转操作，返回旋转后新的根节点x
    //    y                             x
    //  /  \                          /   \
    // T1   x      向左旋转 (y)       y     z
    //     / \   - - - - - - - ->   / \   / \
    //   T2   z                    T1 T2 T3 T4
    //       / \
    //      T3 T4
    ```

  * RR：采取右旋转

    ```java
    // 对节点y进行向右旋转操作，返回旋转后新的根节点x
    //        y                              x
    //       / \                           /   \
    //      x   T4     向右旋转 (y)        z     y
    //     / \       - - - - - - - ->    / \   / \
    //    z   T3                       T1  T2 T3 T4
    //   / \
    // T1   T2
    ```

  * LR（在左子树的右子树下添加元素）：

    ```java
    // 对节点x进行向左旋转操作，转化为LL的情况，然后最y进行右旋转，返回旋转后新的根节点z
    //     y                              y                             z
    //    / \                           /   \                         /   \
    //   x   T4     向左旋转 (x)        z     T4      向右旋转 (y)      x     y 
    //  / \       - - - - - - - ->    / \         - - - - - - - ->  / \    / \ 
    // T1  z                         x  T3                         T1  T2 T3 T4
    //    / \                       / \ 
    //   T1  T2                    T1  T2
    ```

  * RL（在右子树的左子树下添加元素）：

    ```java
    // 对节点x进行向右旋转操作，转化为RR的情况，然后最y进行左旋转，返回旋转后新的根节点z
    //   y                              y                              z
    //  / \                           /   \                          /   \
    // T1  x        向右旋转 (x)      T1    z       向左旋转 (y)       y     x 
    //     / \    - - - - - - - ->    		/ \    - - - - - - - ->  / \    / \ 
    //    z  T4                        	 T2  x                    T1  T2 T3 T4
    //   / \                       					/ \ 
    //  T2  T3                   					 T3  T4
    ```

## 第十三章 红黑树和 2-3树

* 《算法导论》中的红黑树定义

  1. 每个节点或者是红色的，或者是黑色的。

  2. 根节点是黑色的。

  3. 每一个叶子节点（最后的空节点）是黑色的。
  4. 如果一个节点是红色的，那么它的孩子节点都是黑色的
  5. 从任意一个节点到叶子节点，经过的黑色节点是一样的。

* 2-3树

  * 满足二分搜索树的基本性质（左小右大）。

  * 不是二叉树。

  * 每个节点右2个孩子或者3个孩子

    ```java
    //     a                b c 
    //   /   \             / | \
    ```

    存放一个元素有两个孩子的a，称为2节点；

    存放两个元素有三个孩子的b c，称为3节点；

  * 2-3树是一颗**绝对平衡的树**（任意一个节点的左右子树的高度是一样的）。

  * 2-3树添加节点，永远不会添加到空的位置，只会和最后找到的叶子节点做融合，

    如果叶子节点已经是3节点，先融合之后，再进行分裂。

    分裂后，绝对平衡的条件改变后，再将分裂出去的子树的节点，向上一个节点进行融合。保持绝对平衡。

  * 通过不断的"融合-分裂-融合-分裂"等重复操作，来维护绝对的平衡。

* 红黑树和2-3树的等价性

  * 红黑树的黑色节点，等价于2-3树的2节点
  * 红色树的红色节点，和它的父节点，组合起来等价于2-3树的3节点。
  * 所有的红色节点，都是向左倾斜的（把2-3树中3节点的左边的元素，当做右边的元素的左孩子来看待）。

* 红黑树

  * 红黑树是保持"黑平衡"的二叉树。
  * 严格意义上讲，不是平衡二叉树。
  * 最大高度：2logn；
    * 元素查找，比AVL慢。
    * 频繁的添加和删除元素，采用红黑树；
    * 频繁查询的话，AVL适合。

## 第十四章 哈希表

* 哈希函数

  * 将"键"转换为"索引"

  * f(ch) = ch - 'a'。将a-z定义为长度为26的数组，每个为止对应一个字母。减去ASCII的'a'，计算偏移量。

  * 很难保证同一个"键"通过哈希函数的转换对应不同的"索引"。（复杂对象就比较难）

    当不同的"键"通过哈希函数计算得到了同一个"索引"，这就是**哈希冲突**。

  * 在哈希表上的操作，最主要的也是要解决哈希冲突的问题。

  * 哈希表充分体现了：空间换时间。

    * 假设有无限的空间，就可以用O(1)的复杂度完成各项操作
    * 假设有1的空间，只能用O(n)的复杂度完成各项操作（线性表）。

* 哈希函数的设计

  * "键"通过哈希函数得到的"索引"分布越均匀越好。

  * 整型

    * 小范围的正整数直接使用

    * 小范围的负整数进行偏移： -100 ~ 100 —> 0 ~ 200

    * 大整数，如身份证号：110110199901016666

      通常做法：取模。

      * 比如，取后四位。等同于mod 10000，只有一万个空间。

      * 取后六位，等同于mod 1000000，有100万个空间。

      取模，可能导致分布不均匀，比如mod 1000000，就会包括日期，日期取值只能是0 ~ 31。

    * 解决办法：模一个素数。[取模参考值](https://planetmath.org/goodhashtableprimes)

  * 浮点型：转换为整型处理

  * 字符串：转换为整型处理

    * 整型166可以看作：

      ```java
      166 = 1 * 10^2 + 6 * 10^1 +  6 * 10^0
      ```

    * 字符串可以"code"可以看作26进制的整数

      ```java
      code = c * 26^3 + o * 26^2 +  d * 26^1 + e * 26^0
      ```

    * 可以定义成任意进制B

      ```java
      code = c * B^3 + o * B^2 +  d * B^1 + e * B^0
      ```

    * 哈希函数之后的结果

      ```java
      hash(code) = (c * B^3 + o * B^2 +  d * B^1 + e * B^0) % M
      ```

      上述可以转换成下面的形式:

      ```java
      hash(code) = ((((c * B) + o) * B + d) * B + e) % M
      ```

      继续转换

      ```java
      hash(code) = ((((c % M) * B + o) % M * B + d) % M * B + e) % M
      ```

  * 复合类型

    转换为整型处理。处理方式和字符串一样。

    如 Date：year，month，day

    ```java
    hash(date) = (((date.year % M) * B + date.month) % M * B + date.day) % M
    ```

  * 设计原则

    1. 一致性：如果a==b，则hash(a) == hash(b)
    2. 高效性：计算高效简便
    3. 均匀性：哈希值均匀分布

* 哈希冲突的处理 —— 链地址法（Seperate Chaining）

  * 假设键为k1，求索引，先计算k1的hash值，然后取模：

    ```java
    hashCode(k1) % M
    ```

    hashCode的结果有可能为负值，需要把负号抹去。

    * 方法一：求绝对值

    * 方法二：

      ```java
      (hashCode(k1) & 0x7fffffff) % M
      ```

      ```java
      7fffffff = 0111 1111 1111 1111 1111 1111 1111 1111
      ```

      整型的表示是32位，最高位是符号位，最高位为0表示正数，最高位为1表示负数。

      所以上面的计算过后，会抹去符号位。

  * 哈希冲突，做成链表，这就是链地址法。

    每一个地方虽然是链表，但本质是存放一个查找表，所以不一定是链表，也可以用树结构，比如红黑树。

* 哈希表时间复杂度

  * 假设总共有M个地址（数组大小），有N个元素
    * 如果每个地址是链表：O(N / M)
    * 如果每个地址是平衡树：O(log(N / M))
  * 哈希表的优势就是能让时间复杂度达到O(1)级别。实现的方式就是让M动态改变。

* 哈希表的动态空间处理

  * 平均每个地址承载的元素多过一定的程度，即扩容。

    ```java
    N / M = upperTol
    ```

  * 平均每个地址承载的元素少过一定的程度，即缩容。

    ```java
    N / M = lowerTol
    ```

* 哈希表：均摊复杂度是O(1)

  哈希表得到了性能的优势，失去了顺序性。这也是为什么没有完全替代平衡树。

* 集合和映射

  * 集合和映射是一种概念，底层实现可以是链表、树或者哈希表。
  * 有序集合，有序映射：平衡树
  * 无序集合，无序映射：哈希表

* 更多的解决哈希冲突的方法

  * 开放地址法：每一个地址都对所有元素是开放的

    * 线性探测：+1

      遇到哈希冲突时，索引+1，向后寻找下一个为null的位置进行存放。

    * 平方探测：+1，+4，+9，+16
    * 二次哈希：遇到哈希冲突，利用另一个hash函数计算hash值。

    负载率达到一定值，进行resize。

  * 再哈希法 Rehashing

  * Coalesced Hashing

    综合了 Seperate Chaining 和 Open Addressing