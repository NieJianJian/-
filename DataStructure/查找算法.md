## 查找算法

### 1. 顺序查找

* 条件：无序或有序数组或队列
* 原理：按顺序比较每个元素，直到找到关键字位置
* 时间复杂度：O(n)

### 2. 二分查找

* 条件：有序数组

* 原理：查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。

* 实现：

  * 迭代实现

    ```java
    public static int binarySearch(int[] arr, int value) {
        int low = 0;
        int high = arr.length - 1;
        int mid;
        while (low <= high) {
            mid = (low + high) / 2;
            if (value == arr[mid]) {
                return mid;
            } else if (value < arr[mid]) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return -1;
    }
    ```

  * 递归实现

    ```java
    public static int binarySearch(int[] arr, int value, int low, int high) {
        if (value < arr[low] || value > arr[high] || low > high) {
            return -1;
        }
        int mid = (low + high) / 2;
        if (arr[mid] > value) {
            return binarySearch(arr, value, low, mid - 1);
        } else if (arr[mid] < value) {
            return binarySearch(arr, value, mid + 1, high);
        } else {
            return mid;
        }
    }
    ```

* 注：折半查找的前提条件是需要**有序表顺序存储**，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要**频繁执行插入或删除操作**的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。——《大话数据结构》

* 时间复杂度：O(log<sub>2</sub>n)

### 3. 二叉搜索树查找

* 条件：先创建二叉搜索树

  1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；

  2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；

  3）任意节点的左、右子树也分别为二叉查找树。

  二叉搜索树性质：中序遍历得到的是一个有序数组

* 原理：

  1）若b是空树，则搜索失败

  2）若x等于b的根节点的数据域之值，则查找成功；否则：

  3）若x小于b的根节点的数据域之值，则搜索左子树；否则：

  4）查找右子树

* 时间复杂度：平均 O(log<sub>2</sub>n)，最好O(1)，最坏O(n)

### 4. 哈希查找

* 条件：先创建哈希表

* 原理：

  1）用给定的[哈希函数](https://baike.baidu.com/item/哈希函数/9796422)构造[哈希表](https://baike.baidu.com/item/哈希表)；

  2）根据选择的冲突处理方法解决地址冲突

  3）在哈希表的基础上执行哈希查找。

* 时间复杂度：几乎是O(1)，取决于冲突的多少

### 5. 分块查找

* 思想：顺序查找和二分查找的结合

* 原理：

  1）将n个数据元素"按块有序"划分为m块（m ≤ n）。 

  2）每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字； 而第2块中任一元素又都必须小于第3块中的任一元素，……。 

  3）然后使用二分查找及顺序查找。

* 时间复杂度：介于O(n) 和O(logn)之间。

### 6. 插值查找

* 思想：二分查找的改良版
* 原理：插值查找每次从自适应 mid 处开始查找
* 时间复杂度：O(log(logn))

### 7. 斐波那契查找



