## 第6章 类文件结构

　　实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不和包括Java在内的任何语言绑定，它只与"Class文件"这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。

　　Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的。

***

### 1.Class文件的结构

　　**注**：任何一个Class文件都对应着唯一一个类或者接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口可以通过类加载器直接生成）。并不一定以磁盘文件的形式存在。

　　**Class文件**是一组以8位字节为基础的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，当遇到需要占用8位字节以上空间地数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。

　　**Class文件格式**采用一种类似于C语言结构体的伪结构来存储，只有两种数据类型：无符号数和表。

* 无符号数：属于基本数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值。

* 表：由多个无符号数或者其他表做为数据项构成的复合数据类型，以"_info"结尾。用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。

  Class文件格式如下表：

|      类型      |        名称         |          数量          |       含义       |
| :------------: | :-----------------: | :--------------------: | :--------------: |
|       u4       |        magic        |           1            |       魔数       |
|       u2       |    minor_version    |           1            |     次版本号     |
|       u2       |    major_version    |           1            |     主版本号     |
|       u2       | constant_pool_count |           1            | 常量池容量计数值 |
|    cp_info     |    constant_pool    | constant_pool_count -1 |    常量池集合    |
|       u2       |    access_flags     |           1            |     访问标志     |
|       u2       |     this_class      |           1            |      类索引      |
|       u2       |     super_class     |           1            |     父类索引     |
|       u2       |  interfaces_count   |           1            |    接口计数器    |
|       u2       |     interfaces      |    interfaces_count    |   接口索引集合   |
|       u2       |    fields_count     |           1            |     字段数量     |
|   field_info   |       fields        |      fields_count      |     字段集合     |
|       u2       |    methods_count    |           1            |     方法数量     |
|  method_info   |       methods       |     methods_count      |     方法集合     |
|       u2       |  attributes_count   |           1            |     属性数量     |
| attribute_info |     attributes      |    attributes_count    |     属性集合     |

　　无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。

　　<u></u><font color=#FF0000>***Class文件表中的数据项，无论是顺序还是数量，甚至于数据存储的字节序这样的细节，都是被严格选定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不想允许改变。***</font>

### 1.1 魔数与Class文件的版本

　　**魔数**：每个Class文件的头4个字节，用来确定这个文件是否为Class文件。值为：0xCAFEBABE。

　　魔数后的4个字节存储的是Class文件的版本号：第5、6个字节是**次版本号**，第7、8个字节是**主版本号**。

如下Class文件内容：

```
cafe babe 0000 0034 0013 0a00 0400 0f09
...
```

　　开头4个字节的十六进制表示是0xcafebabe，代表次版本号的第5、6个字节值为0x0000，而主版本号的值为0x0034，也就是十进制的52。

### 1.2 常量池

　　紧接着主次版本号之后的就是常量池入口，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，还是Class文件中第一个出现的表类型数据项目。

```
cafe babe 0000 0034 0013 0a00 0400 0f09
```

　　如上所示，常量池容量（偏移地址：0x00000008）为十六进制数0x0013，即十进制的19，这代表常量池中有18项常量，索引值范围为1~18。设计者将第0项常量空出来是有特殊考虑的，这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达"不引用任何一个常量池项目"的含义，这样就可以把索引值置为0来表示。**Class文件结构中只有常量池的容量计数是从1开始的**。

常量池中主要存放两大类常量：字面量和符号引用。

* 字面量：比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等
* 符号引用：属于编译原理方面的概念，包括：
  * 类和接口的全限定名
  * 字段的名称和描述符
  * 方法的名称和描述符

　　Java嗲吗在进行Javac编译的时候，并不像C和C++那样有"连接"这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就是无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

　　常量池中每一项常量都是一个表，表开始的第一位是一个u1类型的标志位（tag），代表当前这个常量属于哪种常量类型。tag取值如下表：

|               类型               | 标志 |           描述           |
| :------------------------------: | :--: | :----------------------: |
|        CONSTANT_Utf8_info        |  1   |    UTF-8编码的字符串     |
|      CONSTANT_Integer_info       |  3   |        整型字面量        |
|       CONSTANT_Float_info        |  4   |       浮点型字面量       |
|        CONSTANT_Long_info        |  5   |       长整型字面量       |
|       CONSTANT_Double_info       |  6   |    双精度浮点型字面量    |
|       CONSTANT_Class_info        |  7   |    类或接口的符号引用    |
|       CONSTANT_String_info       |  8   |     字符串类型字面量     |
|      CONSTANT_Fieldref_info      |  9   |      字段的符号引用      |
|     CONSTANT_Methodref_info      |  10  |    类中方法的符号引用    |
| CONSTANT_InterfaceMethodref_info |  11  |   接口中方法的符号引用   |
|    CONSTANT_NameAndType_info     |  12  | 字段或方法的部分符号引用 |
|    CONSTANT_MethodHandle_info    |  15  |       表示方法句柄       |
|     CONSTANT_MethodType_info     |  16  |       标识方法类型       |
|   CONSTANT_InvokeDynamic_info    |  18  |  表示一个动态方法调用点  |

常量池是最繁琐的数据，**因为这14种常量类型都有自己的结构**。具体内容自行搜索"**常量池中的14种常量项的结构总表**"。

　　由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的最大长度就是length的最大值，CONSTANT_Utf8_info的length属性是一个u2类型的值，能表达的最大值为65535。所以**java程序中如果定义了超过64KB英文字符的变量或者方法名，将会无法编译**。

### 1.3 访问标志

　　**作用**：access_flag用于识别一些类或者接口层次的访问信息。包括：这个Class是类还是接口；是否定义为public；是否定义为abstract；如果类的话，是否被声明为final等。

### 1.4 类索引、父类索引与接口索引集合　　

　　Class文件通过类索引（this_class）、父类索引（super_class）、接口索引集合（interfaces）这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。java.lang.Object的父类索引值为0。接口索引集合用于描述这个类实现了哪些接口。

### 1.5 字段表集合

　　字段表（field_info）用于描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。

　　Java中描述一个字段包含的信息有：字段作用域（public、private、protected）、是实例变量还是类变量（static）、可变性（final）、并发可见性（volatile）、可否被序列化（transient）、字段数据类型（基本类型、对象、数组）、字段名称。

　　参考链接：[《Java虚拟机原理图解》1.4 class文件中的字段表集合](https://cloud.tencent.com/developer/article/1432236)

　　字段表不会列出从超类或者父接口中继承的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持堆外部类的引用，会自动添加指向外部类的实例字段。

### 1.6 方法表集合

　　方法表集合描述和字段表集合描述基本一致。只是access_flag中，volatile和transient不能修饰方法，与之相对的，synchronized、native、strictfp、abstract可以修饰方法。

　　**方法里的Java代码，经过编译期编译成字节码后，存放在方法属性表集合中一个名为"Code"的属性里面。**

　　如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。但有可能出现由编译器自动添加的方法，最典型的是类构造器"< clinit>"方法和实例构造器"< init>"方法。

　　在Java语言中，要重载一个方法，除了要与原来方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名是一个方法中各个参数在常量池中的字段符号引用的集合，因为返回值不包含在特征签名黄总，所以Java语言里是无法仅仅依靠返回值不同来对一个已有方法进行重载的。但在Class文件格式中，只要描述符不是完全一致的两个方法可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，也可以共存与同一个Class文件中。

　　**Java代码方法特征签名**只包括方法名称、参数顺序、参数类型；**字节码的特征签名**还包括方法返回值以及受查异常表。

***

### 2 字节码指令简介

　　Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。

　　字节码指令集是一种具有鲜明特点、优势都很突出的指令集架构，由于限制了Java虚拟机操作码的长度为一个字姐（0~255），这意味着指令集的操作码总数不可能超过256条。

　　不考虑异常处理，Java虚拟机解释器可以用以下伪代码当做基本的执行模型来理解：

```
do {
	自动计算PC寄存器的值加1；
	根据PC寄存器的指示位置，从字节码流中取出操作码；
	if （字节码存在操作数）从字节码流中取出操作数；
	执行操作码所定义的操作；
} while (字节码流长度 > 0);
```

### 2.1 字节码与数据类型 

　　与数据类型相关的字节码指令，i代表对int类型的数据操作，l代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference。

　　Java虚拟机的操作码长度只有一个字节，并非每种数据类型和每一种操作都有对应的指令，有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。

　　大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展为相应的int类型的数据，将boolean和char类型数据零位扩展为相应的int类型数据。大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型做为运算类型。

### 2.2 加载和存储指令

　　加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。

* **将一个局部变量加载到操作数栈**：iload、iload_ < n>、aload、aload_ < n>等；

* **将一个数值从操作数栈存储到局部变量表**：istore、istore _< n>、astore、astore _< n>等；

* **将一个常量加载到操作数栈**：bipush、sipush、ldc、iconst_m1、iconst _< i>等；

* **扩充局部变量表的访问索引的指令**：wide。

  **注**：当int取值-1~5采用iconst指令，取值-128~127采用bipush指令，取值-32768~32767采用sipush，取值-2147483648~2147483647采用ldc指令。

　　存储数据的操作数栈和局部变量表主要是由加载和存储指令进行操作，访问对象字段或数组元素的指令也会向操作数栈传输数据。

### 2.3 运算指令

　　运算或算数指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。

* **加法指令**：iadd、ladd、fadd、dadd。
* **减法指令**：isub、lsub、fsub、dsub。
* **乘法指令**：imul、lmul、fmul、dmul。
* **除法指令**：idiv、ldiv、fdiv、ddiv。
* **求余指令**：irem、lrem、frem、drem。
* **取反指令**：ineg、lneg、fneg、dneg。
* **位移指令**：ishl、ishr、iushr、lshl、lshr、lushr。
* **按位或指令**：ior、lor。
* **按位与指令**：iand、land。
* **按位异或指令**：ixor、lxor。
* **局部变量自增指令**：iinc。
* **比较指令**：dcmpg、dcmpl、fcmpg、fcmpl、lcmp。

　　**整型数据溢出**：两个很大的正整数相加，结果可能是一个负数。

### 2.4 类型转换指令

* **宽化类型转换**（即小范围类型向大范围类型的安全转换），Java虚拟机直接支持（无需显式的转换指令）
  * int类型到long、float或者double类型。
  * long类型到float、double类型。
  * float类型到double类型。
* **窄化类型转换**时，必须显式的使用转换指令，如：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f。窄化类型转换可能导致转换结果产生不同的正负号、不同的数量级，可能会导致数值的精度缺失。

### 2.5 对象创建与访问指令

　　类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。

* **创建类实例的指令**：new。
* **创建数组的指令**：newarray、anewarray、multianewarray。
* **访问类字段（static，或称为类变量）和实例字段（非static，或称为实例变量）**：getfield、putfield、getstatic、putstatic。
* **把一个数组元素加载到操作数栈的指令**：baload、caload、saload、iaload、laload、faload、daload、aaload。
* **将一个操作数栈的值存储到数组元素的指令**：bastore、castore、sastore、iastore、fastore、dastore、aastore。
* **取数组长度的指令**：arraylength。
* **检查类实例类型的指令**：instanceof、checkcast。

### 2.6操作数栈管理指令

* **将操作数栈的栈顶一个或两个元素出栈**：pop、pop2.
* **复制栈顶一个或两个数值并将复制值或双份复制值重新压入栈顶**：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2。
* **将栈最顶端的两个数值互换**：swap。

### 2.7 控制转移指令

### 2.8 方法调用和返回指令

* **invokevirtual**指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）。
* **invokeinterface**指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。
* **invokespecial**指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。
* **invokestatic**指令用于调用类方法（static方法）
* **invokedynamic**指令用于在运行时动态解析出调用点限定符所引用的方法，并执行。前4条指令的分派逻辑固化在Java虚拟机内部，而invokedynamic指令的分派逻辑式由用户所设定的引导方法决定的。

### 2.9 异常处理指令

　　在Java虚拟机中，处理异常（catch语句）不实由字节码指令来实现的（很久之前曾经使用jsr和ret指令来实现，现在已经不用了），而是采用异常表来完成的。

### 2.10 同步指令

***

