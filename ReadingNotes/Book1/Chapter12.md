## 第12章 Java内存模型与线程

　　由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代设计算系统都不得不加入一层读写速度尽可能接近处理器运算速度的高级缓存来做为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存中，这样处理器就无需等待缓慢的内存读写了。

　　基于高速缓存的存储交互解决了处理器和内存的速度矛盾，但是带来了新的问题：**缓存一致性**。

***

### 1 Java内存模型

### 1.1 主内存与工作内存

　　Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。

　　Java内存模型规定了所有变量都存储在**主内存**，每条线程还有自己的**工作内存**。线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存的变量。线程间变量值的传递需要通过主内存来完成。线程、主内存、工作内存交互关系如下图：

![](https://raw.githubusercontent.com/NieJianJian/AndroidNotes/master/Picture/memorymodel.jpg)

　　这里的主内存、工作内存和Java内存区域的Java堆、栈、方法区等不是一个层次的内存划分。如果非要对应的化，从变量、主内存、工作内存的定义来看，主内存主要对应Java堆中的对象实例数据部分（Java堆除了实例数据，还是对象的其他信息），而工作内存对应虚拟机栈中的部分区域。

### 1.2 内存间交互操作

　　Java内存模型定义了以下8中操作来完成变量在主内存和工作内存之间的交互，虚拟机实现时必须保证下面的每一种操作都是原子的、不可再分的。

* **lock**（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
* **unlock**（解锁）：作用于主内存变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
* **read**（读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
* **load**（载入）：作用于工作内存变量，它把read操作从主内存中得到变量放入工作内存变量副本中。
* **use**（使用）：作用于工作内存，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
* **assign**（赋值）：作用于工作内存变量。它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
* **store**（存储）：作用于工作内存变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
* **write**（写入）：作用于主内存变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

### 1.3 对于volatile型变量的特殊规则

　　[Volatile](https://github.com/NieJianJian/AndroidNotes/blob/master/ReadingNotes/Book1/Volatile.md)

