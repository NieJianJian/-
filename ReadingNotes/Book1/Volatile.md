## 对于volatile型变量的特殊规则

关键字volatiile可以说是Java虚拟机提供的最轻量级的同步机制。

当一个变量定义为volatile之后，将具备两种特性：

* **第一是保证此变量对所有线程的可见性**，这里的可见性是指当一条线程修改了变量的值，新值对于其他线程来说是立即得知的。

  　　volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在不一致的问题），但是Java里面的运算并**非原子操作**，导致volatile变量的运算在并发下一样是不安全的。

  　　由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.current中的原子类）来保证原子性：

  * 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
  * 变量不需要与其他的状态变量共同参与不变约束。

* **第二是禁止指令重排序优化**，普通的变量仅仅会保证在该方法执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的"*线程内表现为串行的语义*"。