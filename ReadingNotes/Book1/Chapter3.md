##  第3章 垃圾收集器与内存分配策略

　　Java堆和方法区里，一个接口中的实现类需要的内存可能不一样，一个方法的多个分支需要的内存也不一样，我们只有在程序处于运行期间才知道会创建哪些对象，这部分内存的分配和回收是动态的，**垃圾收集器关注的是这部分内存**。

### 1 对象已死吗？

　　堆里面几乎存放着Java世界中几乎所有的对象实例。

### 1.1 引用计数算法

　　**原理：**如何判断对象是否存活？给对象添加一个引用计数器，每当有一个地方引用它，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

　　**缺点：**很难解决对象之间相互循环引用的问题。如objA.instance=objB，objB.instance=objA，除此之外，这两个对象再无任何引用。但是GC无法回收。

### 1.2 可达性分析算法

　　**原理：**通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用练，当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明对象是不可用的。

　　图：可达性分析算法判定对象是否可回收，如下：

![](https://raw.githubusercontent.com/NieJianJian/AndroidNotes/master/Picture/kedaxingfenxi.jpg)

　　Java语言中，可作为GC Roots的对象包括下面几种：

* 虚拟机栈（栈帧中的本地变量表）中引用的对象。
* 方法区中类静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法栈中JNI（Native方法）引用的对象。

### 1.3 再谈引用

　　**定义**：如果reference类型的数据中存储的数值代表的时另外一块内存的起始地址，就成为这块内存代表着一个引用。

　　**分类**：分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种。

* **强引用**就是指代码中普遍存在的，类似"Object obj = new Object()"这类的引用，只要强引用还存在，垃圾收集器*永远不会*回收掉被引用的对象。
* **软引用**用来描述一些还有用但非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出异常。
* **弱引用**用来描述非必需的对象，但强度比软引用弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。

* **虚引用**时最弱的引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的为一目的是*能在这个对象被收集器回收的时收到一个系统通知。*

### 1.4 生存还是死亡

　　可达性分析算法中不可达的对象，至少要经历两次标记过程：**如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那么将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行finalize()方法。**当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况视为"没有必要执行"。

　　finalize()方法是对象逃脱死亡命运的最后一次机会（**因为一个对象的finalize()方法最多只会被系统自动调用一次**），如果对象要在finalize()成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可，如吧自己（this关键字）赋值给某个类变量或者对象的成员变量，那么第二次标记时它将被移出"即将回收"的集合。

　　finalize()能做的所有工作，使用try-finally或者其他方式都可以做的更好、更及时。

### 1.5 回收方法区

　　Java堆可以分为新生代和老年代，方法区也常被称为"**永久代**"。

　　Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的性价比较低：在堆中，尤其是新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。

　　永久代的垃圾收集主要回收两部分内容：**废弃常量和无用的类**。

* 废弃常量：与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串"abc"已经进入了常量池中，但是当前系统没有任何一个String对象是叫做"abc"的，换句话说，就是没有任何String对象引用常量池中的"abc"常量，也没有其他地方引用这个字面量，如果这时发生内存回收，而且必要的话，这个"abc"常量就会被系统清理出常量池。常量池中的其他类、方法、字段的符号引用与此类似。
* 无用的类：需要同时满足下面三个条件才能算是无用的类。（可以回收，并非必然回收）
  * 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例
  * 加载该类的ClassLoader已经被回收
  * 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

***

### 2 垃圾收集算法

### 2.1 标记 - 清除算法

　　**原理：**首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

　　**缺点：**一是效率问题，标记和清除两个过程效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记—清除算法执行图如下：

![](https://raw.githubusercontent.com/NieJianJian/AndroidNotes/master/Picture/biaojiqingchusuanfa.jpg)

### 2.2 复制算法

　　**原理：**将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次性清理掉。

　　**优点：**每次只对整个半区进行内存回收，内存分配时无需考虑内存碎片等复杂情况，只要移动堆顶的指针，按顺序分配内存即可，简单、高效。

　　**缺点：**将内存缩小为原来的一半，说明有一半的内存是浪费的。

　　复制算法的执行过程图如下：

![](https://raw.githubusercontent.com/NieJianJian/AndroidNotes/master/Picture/fuzhisuanfa.png)

　　现在商业虚拟机都采用复制算法回收**新生代**。新生代中的对象98%都朝生夕死，不需要按照1：1来划分内存，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8：1，所以每次只有10%的内存被"浪费"。我们无法保证每次回收都只有不多余10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。

### 2.3 标记 - 整理算法

　　**原理：**针对老年代的特点。标记过程和"标记-清除"算法一样，但后续步骤不实直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端便捷以外的内存。示意图如下：

![](https://raw.githubusercontent.com/NieJianJian/AndroidNotes/master/Picture/biaojizhenglisuanfa.jpg)

### 2.4 分代收集算法

