## 第11章 晚期（运行期）优化

　　**即时编译器（JIT编译器）**：将"热点代码"（运行频繁的方法和代码块）编译成与本地平台相关的机器码。

***

### 1 HotSpot虚拟机内的即时编译器

* 为何HotSpot虚拟机要使用解释器与编译器并存的架构？
* 为何HotSpot虚拟机要实现两个不同的即时编译器。
* 程序何时使用解释器执行？何时使用编译器执行？
* 哪些程序代码会被编译为本地代码？如何编译为本地代码？
* 如何从外部观察即时编译器的编译过程和编译结果？

### 1.1 解释器与编译器

解释器和编译器两者各有优势：

* 当程序需要迅速启动和执行的时候，解释器可以先发挥作用，省去编译时间，立即执行。
* 程序运行后，随着时间推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，获取更高执行率。
* 当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之使用编译执行提升效率
* 解释器还可以做为编译器激进优化时的一个"**逃生门**"，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类后类型继承结构出现变化、出现"罕见陷阱"时可以通过逆优化退回到解释状态继续执行。

图：**解释器与编译器的交互**，如下：

![](https://raw.githubusercontent.com/NieJianJian/AndroidNotes/master/Picture/jieshibianyijiaohu.jpg)

　　HotSpot虚拟机内置两个即时编译器，分别为Client Compiler和Server Compiler，简称C1编译器和C2编译器。程序使用哪个编译器，取决于虚拟机运行模式。

### 1.2 编译对象与触发条件

被即时编译器编译的"热点代码"有两类：

* 被多次调用的方法
* 被多次执行的方法

　　第一种情况，编译器会以整个方法作为编译对象；第二种情况，尽管编译动作是由循环体所触发，但编译器依然会以整个方法作为编译对象。这种编译方式由于发生在方法执行过程中，被称为**栈上替换**（OSR编译，即方法栈帧还在粘上，方法就被替换了）。

判断一段代码是不是热点代码，是不是需要触发即时编译器，这样的行为称为**热点探测**，主要的热点探测判定方式有两种，如下：

* 基于采样的热点探测：虚拟机会周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这个方法就是"热点方法"。好处是实现简单、高效，还可以很容易地获取方法调用关系，缺点是不精确。
* 基于计数器的热点探测：虚拟机会给每个方法建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值，就认定为"热点方法"。缺点时实现麻烦，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但结果精确。

HotSpot虚拟机采用基于计数器的热点探测方法，因此它为每个方法准备了以下两类计数器：

* **方法调用计数器**：用于统计方法被调用的次数，它的默认阈值在Client模式下时1500次，在Server模式下是10000次，这个阈值可通过虚拟机参数设定。执行过程如下：
  * 当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本
  * 如果存在，则优先使用编译后的本地代码来执行
  * 如果不存在已被编译过的版本，则将此方法调用计数器值加1
  * 然后判断方法调用器与回边计数器之和是否超过阈值
  * 如果超过阈值，将会向即时编译器提交一个该方法的代码编译请求。
* **回边计数器**：用于统计一个方法中循环体代码执行的次数（回边次数，并非所有的循环都是回边，如空循环），在字节码遇到控制流向后跳转的指令称为"回边"，建立回边计数器统计的目的是为了触发OSR编译。虚拟机在Client模式下和Server模式下的阈值计算公式不一样。回边计数器执行过程同方法调用计数器基本类似。
* 方法调用计数器超过规定的时间限度，还未达到阈值，调用计数器值将减少一半，这个过程称为热度的衰减，这段时间称为方法统计的半衰周期。回边计数器没有热度衰减，是绝对次数。

　　从源码来看，在MethodOop.hpp（**一个methodOop对象代表一个Java方法**）中，定义了Java在虚拟机中的内存布局，其中包括方法计数器和回边计数器所在的位置和长度。

### 1.3 编译过程

Server Compiler和Client Compiler两个编译器的编译过程不一样：

* C1是一个简单快速的三段式编译器，关注点在局部性的优化，而放弃许多耗时较长的全局优化手段。

  * 第一阶段，一个平台独立的前端将字节码构成一种高级中间代码表示（HIR）。HIR使用静态单分配（SSA）的形式来代表代码值，这使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器会在字节码上完成一些基础优化，如**方法内联**、**常量传播**等优化将在字节码被构造成HIR之前完成。

  * 第二阶段，一个平台相关的后端从HIR中产生低级中间代码表示（LIR），在此之前会在HIR上完成另外一些优化，如**空值检查消除**、**范围检查消除**等，以便让HIR达到更高效的代码表示形式。

  * 最后阶段是在平台相关的后端使用线性扫描算法在LIR上分配寄存器，并在LIR上做窥孔优化，然后产生机器码。

    Client Compiler的大致执行过程如下图：（图：**Client Compiler架构**）

    ![](https://raw.githubusercontent.com/NieJianJian/AndroidNotes/master/Picture/clientcompiler.jpg)

* C2是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，它会执行所有经典的优化动作，如：**无用代码消除**、**循环展开**、**循环表达式外提**、**消除公共子表达式**、**常量传播**、**基本块重排序**、**范围检查消除**、**空值检查消除**、**守护内联**、**分支频率预测**等。

```java
public static int doubleValue(int i) {
    for (int j = 0; j < 100000; j++);
    return i * 2;
}
```

**Q**：如上代码，把空循环当做程序延时手段，是否真的有作用？

**A**：空循环操作会被消除，实际上不会被执行。

***

### 2 编译优化技术

