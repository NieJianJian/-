## 第11章 晚期（运行期）优化

　　**即时编译器（JIT编译器）**：将"热点代码"（运行频繁的方法和代码块）编译成与本地平台相关的机器码。

***

### 1 HotSpot虚拟机内的即时编译器

* 为何HotSpot虚拟机要使用解释器与编译器并存的架构？
* 为何HotSpot虚拟机要实现两个不同的即时编译器。
* 程序何时使用解释器执行？何时使用编译器执行？
* 哪些程序代码会被编译为本地代码？如何编译为本地代码？
* 如何从外部观察即时编译器的编译过程和编译结果？

### 1.1 解释器与编译器

解释器和编译器两者各有优势：

* 当程序需要迅速启动和执行的时候，解释器可以先发挥作用，省去编译时间，立即执行。
* 程序运行后，随着时间推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码，获取更高执行率。
* 当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之使用编译执行提升效率
* 解释器还可以做为编译器激进优化时的一个"**逃生门**"，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新类后类型继承结构出现变化、出现"罕见陷阱"时可以通过逆优化退回到解释状态继续执行。

图：**解释器与编译器的交互**，如下：

![](https://raw.githubusercontent.com/NieJianJian/AndroidNotes/master/Picture/jieshibianyijiaohu.jpg)

　　HotSpot虚拟机内置两个即时编译器，分别为Client Compiler和Server Compiler，简称C1编译器和C2编译器。程序使用哪个编译器，取决于虚拟机运行模式。

### 1.2 编译对象与触发条件

被即时编译器编译的"热点代码"有两类：

* 被多次调用的方法
* 被多次执行的方法

　　第一种情况，编译器会以整个方法作为编译对象；第二种情况，尽管编译动作是由循环体所触发，但编译器依然会以整个方法作为编译对象。这种编译方式由于发生在方法执行过程中，被称为**栈上替换**（OSR编译，即方法栈帧还在粘上，方法就被替换了）。

判断一段代码是不是热点代码，是不是需要触发即时编译器，这样的行为称为**热点探测**，主要的热点探测判定方式有两种，如下：

* 基于采样的热点探测：虚拟机会周期性检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，那这个方法就是"热点方法"。好处是实现简单、高效，还可以很容易地获取方法调用关系，缺点是不精确。
* 基于计数器的热点探测：虚拟机会给每个方法建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值，就认定为"热点方法"。缺点时实现麻烦，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但结果精确。

HotSpot虚拟机采用基于计数器的热点探测方法，因此它为每个方法准备了以下两类计数器：

* **方法调用计数器**：用于统计方法被调用的次数，它的默认阈值在Client模式下时1500次，在Server模式下是10000次，这个阈值可通过虚拟机参数设定。执行过程如下：
  * 当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本
  * 如果存在，则优先使用编译后的本地代码来执行
  * 如果不存在已被编译过的版本，则将此方法调用计数器值加1
  * 然后判断方法调用器与回边计数器之和是否超过阈值
  * 如果超过阈值，将会向即时编译器提交一个该方法的代码编译请求。
* **回边计数器**：用于统计一个方法中循环体代码执行的次数（回边次数，并非所有的循环都是回边，如空循环），在字节码遇到控制流向后跳转的指令称为"回边"，建立回边计数器统计的目的是为了触发OSR编译。虚拟机在Client模式下和Server模式下的阈值计算公式不一样。回边计数器执行过程同方法调用计数器基本类似。
* 方法调用计数器超过规定的时间限度，还未达到阈值，调用计数器值将减少一半，这个过程称为热度的衰减，这段时间称为方法统计的半衰周期。回边计数器没有热度衰减，是绝对次数。

　　从源码来看，在MethodOop.hpp（**一个methodOop对象代表一个Java方法**）中，定义了Java在虚拟机中的内存布局，其中包括方法计数器和回边计数器所在的位置和长度。

### 1.3 编译过程

Server Compiler和Client Compiler两个编译器的编译过程不一样：

* C1是一个简单快速的三段式编译器，关注点在局部性的优化，而放弃许多耗时较长的全局优化手段。

  * 第一阶段，一个平台独立的前端将字节码构成一种高级中间代码表示（HIR）。HIR使用静态单分配（SSA）的形式来代表代码值，这使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器会在字节码上完成一些基础优化，如**方法内联**、**常量传播**等优化将在字节码被构造成HIR之前完成。

  * 第二阶段，一个平台相关的后端从HIR中产生低级中间代码表示（LIR），在此之前会在HIR上完成另外一些优化，如**空值检查消除**、**范围检查消除**等，以便让HIR达到更高效的代码表示形式。

  * 最后阶段是在平台相关的后端使用线性扫描算法在LIR上分配寄存器，并在LIR上做窥孔优化，然后产生机器码。

    Client Compiler的大致执行过程如下图：（图：**Client Compiler架构**）

    ![](https://raw.githubusercontent.com/NieJianJian/AndroidNotes/master/Picture/clientcompiler.jpg)

* C2是专门面向服务端的典型应用并为服务端的性能配置特别调整过的编译器，它会执行所有经典的优化动作，如：**无用代码消除**、**循环展开**、**循环表达式外提**、**消除公共子表达式**、**常量传播**、**基本块重排序**、**范围检查消除**、**空值检查消除**、**守护内联**、**分支频率预测**等。

```java
public static int doubleValue(int i) {
    for (int j = 0; j < 100000; j++);
    return i * 2;
}
```

**Q**：如上代码，把空循环当做程序延时手段，是否真的有作用？

**A**：空循环操作会被消除，实际上不会被执行。

***

### 2 编译优化技术

**eg**：优化前的原始代码如下

```java
static class B{
    int value;
    final int get() { return value; }
}
public void foo() {
    y = b.get();
    z = b.get();
    sum = y + z;
}
```

首先，这些代码优化变化是建立在代码的某种中间表示或机器码只上，不是建立在Java源码之上。

**方法内联**：去除方法调用成本（如建立栈帧等），为其他优化建立良好的基础。内联后代码如下：

```java
public void foo() {
    y = b.value;
    z = b.value;
    sum = y + z;
}
```

**冗余访问消除**："y=b.value"已经保证了变量y和b.value是一致，代码如下：

```java
public void foo() {
    y = b.value;
    z = y;
    sum = y + z;
}
```

**复写传播**：因为此代码没有必要使用变量z，它与变量y完全相等，所以替换，代码如下：

```java
public void foo() {
    y = b.value;
    y = y;
    sum = y + y;
}
```

**无用代码消除**：永远不会执行的代码，或完全没有意义的代码，可称为"Dead Code"。代码如下：

```java
public void foo() {
    y = b.value;
    sum = y + y;
}
```

最优代表性的优化技术：

* 语言无关的经典优化技术之一：公共子表达式消除
* 语言相关的经典优化技术之一：数组范围检查消除
* 最重要的优化技术之一：方法内联
* 最前沿的优化技术之一：逃逸分析

### 2.1 公共子表达式消除

　　**含义**：如果一个表达式E已经计算过了，并且从先前的计算到现在E中没有所有变量的值都没有变化，那么E的这次出现就成为了公共子表达式。如果仅限于程序的基本块内，称为局部公共子表达式消除，如果范围涵盖了多个基本块，称为全局公共子表达式消除。

**eg**：如下代码：

```java
int d = (c * b) * 12 + a + (a + b * c);
```

编译器检测到"c * b"和"b * c"是一样的表达式，所以表达式被视为：

```java
int d = E * 12 + a + (a + E);
```

编译器还可能进行另外一种优化：**代数化简**，表达式变为：

```java
int d = E * 13 + a * 2;
```

### 2.2 数组边界检查消除

　　如果有一个数组foo[]，在Java语言中每次访问数组元素foo[i]的时候系统会自动进行*上下界的范围检查*，即检查i必须满足i>=0 && i<foo.length这个条件，否则抛出数组角标越界异常。每次数组元素的读写都带有一次隐含的条件判定操作，是一种性能负担。

　　数组边界检查肯定要做的，但是不是必须在运行期一次不漏的检查，可以"商量"。例如：数组下表是一个常量，如foot[3]，只要在编译期根据数据流分析来确定foo.length的值，并判断下表"3"没有越界，执行的时候就无需判断了。如数组访问发生在循环中，只要分析判断取值范围在[0,foo.length)之内，那整个循环可以把数组的上下界检查消除。

　　除了数组边界检查优化这种尽可能把运行期检查提到编译器完成的思路之外，还有一个避免思路——隐式异常处理，Java空指针检查和算数运算中除数为零的检查都采用这种思路。如下例子：

```java
if (foo != null) {
    return foo.value;
} else {
    throw new NullPointException();
}
```

经过隐式异常优化之后，代码如下：

```java
try {
    return foo.value;
} catch(segment_fault) {
    uncommon_trap();
}
```

### 2.3 方法内联

　　**含义**：把目标方法的代码复制到发起调用的方法之中，避免发生真实的方法调用。

　　一些方法无法内联的**原因**：只有使用invokespecial指令调用的私有方法、实例构造器、父类方法以及使用invokestatic指令进行调用的静态方法才是编译期进行解析的，除了上述4种方法外，其他的Java方法调用都需要在运行时进行方法接收者的多台选择，并且都有可能存在多余一个版本的方法接受者（最多再除去final修饰的方法，尽管使用invokevirtual指令调用，但也是非虚方法）。**Java语言中默认的实例方法是虚方法**。

　　对于一个虚方法，编译期做内联的时候无法确定应该使用哪个方法版本。如之前的代码中把"b.get()"内联为"b.value"的化，不依赖上下文是无法确定b的实例类型（子父类继承，重写方法的情况下）。

　　为了解决虚方法的内联问题，引入"**类型继承关系分析**"*（CHA）的技术，用于确定目前已加载的类中，某个接口是否有多于一种的时候，某个类是否存在子类、子类是否为抽象类等信息。

　　编译器在进行内联时：

* 如果是非虚方法，那么直接内联就可以了，这时候的内联是有稳定前提保障的。
* 如果遇到虚方法，则会向CHA查询此方法在当前程序下是否有多个目标版本可选择。
* 如果查询结果只有一个版本，那么可以进行内联，不过这种内联属于激进优化，需预留一个"逃生门"，称为**守护内联**。
* 如果程序的后续执行过程中，虚拟机一直没有加载到会令这个方法接收者的继承关系发生变化的类，那么内联优化的代码就可以一直执行下去。
* 如果加载了导致继承关系发生变化的新类，那则抛弃已经编译的代码，退回到解释状态执行，或重新编译。

　　如果向CHA查询出来的结果有多个版本的目标方法可供选择，则编译器会进行最后一次努力，使用**内联缓存**来完成方法内联。工作原理是：

* 未发生方法调用前，内联缓存状态为空
* 第一次调用发生后，缓存记录下方法接收者的版本信息，并且每次进行方法调用时都比较接收者版本
* 如果以后进来的每次调用的方法接收者版本都一致，那这个内联就可以一直使用下去
* 如果发生了方法接收者不一致的情况，就说明程序真正使用了虚方法的多态特性，这时会取消内联，查找虚方法表进行方法分派。

### 2.4 逃逸分析

　　逃逸分析的基本行为就是分析对象动态作用域：

* 当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为**方法逃逸**。
* 如果被外部线程访问到，比如赋值给类变量或可以在其他线程中访问的实例变量，称为**线程逃逸**。

　　如果证明一个方法不会逃逸到方法或线程之外，则可能为这个变量进行一些高效的优化，如下所示：

* **栈上分配**：如果能确定一个对象不会逃逸出方法外，那让这个对象在栈上分配内存将会是一个很不错的注意，对象所占用的内存空间就可以随栈帧出栈而销毁。
* **同步消除**：如果能确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定不会有竞争，对这个变量实施的同步措施可以消除掉。
* **标量替换**：如果能确定一个类不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。
  * *标量*是指一个数据无法再分解为更小的数据来表示了，Java虚拟机中原始数据类型（int、long等数值以及reference类型等）都不能再进一步分解。相对的，如果一个数据可以继续分解，称作*聚合量*，Java中的对象就是典型的聚合量。如果把一个Java对象拆散，根据程序访问情况，将其使用到的成员变量恢复原始类型来访问就叫做**标量替换**。
  * 将对象拆分后，除了可以让对象的成员变量在栈上分配和读写，还可以进一步优化。

