## 第1章 并发编程的挑战

### 1 上下文切换

* 时间片一般是**几十毫秒（ms**）
* **上下文切换**：CPU切换时间片前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。
* 当并发执行累计不超过百万次的时候，速度比串行执行累加操作要慢，因为线程有创建上下文切换的开销。
* 测试上下文切换次数和时长的工具
  * Lmbench3测量上下文切换的时长
  * smstat可以测量上下文切换的次数

#### 1.1 如何减少上下文切换

* 无锁并发编程。多线程竞争锁，会引起上下文切换。所以多线程处理数据时，可以想办法避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同端的数据。
* CAS算法。Atomic包使用CAS算法来更新数据，而不需要加锁。
* 使用最少线程。避免创建不需要的线程。
* 协程。单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

#### 1.2 死锁

避免死锁的几个常见方法

* 避免一个线程同时获取多个锁
* 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源
* 尝试使用定时锁，使用`lock.tryLock(timeout)`来替代使用内部锁机制。
* 对于数据库锁，加锁和解锁必须在一个数据链接中，否则会出现解锁失败的情况。





