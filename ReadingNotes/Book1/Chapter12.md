## 第12章 Java内存模型与线程

　　由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代设计算系统都不得不加入一层读写速度尽可能接近处理器运算速度的高级缓存来做为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存中，这样处理器就无需等待缓慢的内存读写了。

　　基于高速缓存的存储交互解决了处理器和内存的速度矛盾，但是带来了新的问题：**缓存一致性**。

***

### 1 Java内存模型

### 1.1 主内存与工作内存

　　Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。

　　Java内存模型规定了所有变量都存储在**主内存**，每条线程还有自己的**工作内存**。线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存的变量。线程间变量值的传递需要通过主内存来完成。线程、主内存、工作内存交互关系如下图：

![](https://raw.githubusercontent.com/NieJianJian/AndroidNotes/master/Picture/memorymodel.jpg)

　　这里的主内存、工作内存和Java内存区域的Java堆、栈、方法区等不是一个层次的内存划分。如果非要对应的化，从变量、主内存、工作内存的定义来看，主内存主要对应Java堆中的对象实例数据部分（Java堆除了实例数据，还是对象的其他信息），而工作内存对应虚拟机栈中的部分区域。

### 1.2 内存间交互操作

　　Java内存模型定义了以下8中操作来完成变量在主内存和工作内存之间的交互，虚拟机实现时必须保证下面的每一种操作都是原子的、不可再分的。

* **lock**（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
* **unlock**（解锁）：作用于主内存变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
* **read**（读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
* **load**（载入）：作用于工作内存变量，它把read操作从主内存中得到变量放入工作内存变量副本中。
* **use**（使用）：作用于工作内存，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
* **assign**（赋值）：作用于工作内存变量。它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
* **store**（存储）：作用于工作内存变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
* **write**（写入）：作用于主内存变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。

### 1.3 对于volatile型变量的特殊规则

　　[Volatile](https://github.com/NieJianJian/AndroidNotes/blob/master/ReadingNotes/Book1/Volatile.md)

### 1.4 对于long和double型变量的特殊规则

　　Java内存模型要求lock、unlock、read、load、assign、use、store、write这8个操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作分为两次32位的操作来执行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这个4个操作的原子性，这就是所谓的**long和double的非原子协定**。

　　不过目前大部分虚拟机都选择把64位数据的读写作为原子操作来对待，所以在编写代码是**一般不需要把用用到的long和double变量专门声明为volatile**。

#### 1.5 原子性、可见性与有序性

* **原子性**：由Java内存模型来直接保证原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为*基本数据类型的访问读写是具备原子性的（long和double除外）*。

  　　　　如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和moniterexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，所以**在synchronized块之间的操作也具备原子性**。

* **可见性**：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。
  * volatile保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。
  * synchronized同步块的可见性是由"对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）"这条规则获得的。
  * final关键字的可见性是指：被final修饰的字符在构造器中一旦初始化完成，并且构造器没有把"this"引用传递出去（this引用逃逸是一件很危险的事，其他线程可能通过这个引用访问到"初始化了一半"的对象），那在其他线程中就能看见final字段的值。

* **有序性**：如果在本线程内观察，所有的操作都是有序的（指"线程内表现为串行的语义"）；如果在一个线程中观察另一个线程，所有操作都是无序的（指"指令重排序"现象和"工作内存与主内存同步延迟"现象）。
  * volatile关键字本身就包含了禁止指令重排序的语义
  * synchronized则是由"一个变量在同一时刻只允许一条线程对其进行lock操作"这条规则获得，这条规则决定了持有同一个锁的两个同步块只能串行地进入。

#### 1.6 先行发生原则

　　下面是Java内存模型中一些"天然的"先行发生关系（只有这些）：

* **程序次序规则**：在一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确的说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
* **管程锁定规则**：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调是同一个锁，而"后面"是指时间上的先后顺序。
* **volatile变量规则**：对一个volatle变量的写操作先行发生于后面对这个变量的读操作，这里的"后面"同样是指时间上的先后顺序。
* **线程启动规则**：Thread对象的start()方法先行于此线程的每一个动作。
* **线程终止规则**：线程的所有操作都先行于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止。
* **线程中断规则**：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupt()方法检测到是否有中断发生。
* **对象终结规则**：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
* **传递性**：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。

　　时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候，不要收到时间顺序的干扰，一切以先行发生原则为准。

***

### 2 Java与线程

### 2.1 线程的实现

实现线程的主要3种方式：使用内核线程实现、使用用户线程实现、使用用户线程加轻量级进程混合实现。

* **1.使用内核线程实现**

  　　　　内核线程（KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就由能力同时处理多件事情，支持多线程的内核就叫做多线程内核。

  　　程序一般不会直接使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。这种轻量级进程与内核线程之间1：1的关系称为一对一的线程模型。

  　　由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响整个进程继续工作，但是轻量级进程有它的局限性：首先，由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态和内核态中来回切换。其次，每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源（如内核线程的栈空间），因此一个系统支持轻量级进程的数量是有限的。

* **2.使用用户线程实现**

  　　广义上讲，一个线程只要不是内核线程，就可以认为是用户线程（UT）。

  狭义上讲，用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在。

  这种进程与用户线程之间1：N的关系称为一对多的线程模型。

* **3.使用用户线程加轻量级进程混合实现**

  　　N：M

### 2.2 Java线程调度

　　线程调度是指系统为线程分配处理器使用权的过程。主要调度方式分为以下两种：

* **协同式线程调度**：线程的执行时间由线程本身来控制，线程自己执行完，主动通知系统切换到另一个线程。
  * 好处：实现简单，切换操作自身可知，所以没有什么线程同步问题。
  * 坏处：执行时间不可控，线程编写有问题，将导致阻塞，无法切换。
* **抢占式线程调度**：线程的执行时间由系统来分配，线程切换自己无法决定（Thread.yield()可以出让执行时间，但无法主动获取执行时间）。**Java使用的线程调度就是抢占式调度。**

　　Java语言一共设置了10个级别的优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY），但是，线程优先级并不靠谱，因为：

* Java的线程是通过映射到系统的原生线程上来实现的，所以线程的调度最终还是取决于操作系统。
* Java线程的优先级并不能和操作系统提供的优先级一一对应。
* 优先级可能会被系统自行改变。

### 2.3 状态切换

　　在任意一个时间点，一个线程只能有且只有其中的一种状态，5种状态分别如下：

* **新建**：创建后尚未启动的线程
* **运行**：Runnable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也可能正在等待CPU为它分配执行时间。
* **无限期等待**：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式的唤醒。以下方法会让线程陷入无限期等待状态：
  * 没有设置Timeout参数的Object.wait()方法
  * 没有设置Timeout参数的Thread.join()方法
  * LockSupport.park()方法。
* **限期等待**：处于这种状态的线程不会被分配CPU执行时间，不过无需等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：
  * Thread.sleep()方法。
  * 设置了Timeout参数的Object.wait()方法。
  * 设置了Timeout参数的Thread.join()方法。
  * LockSupport.parkNanos()方法。
  * LockSupport.parkUntil()方法。
* **阻塞**：线程被阻塞了，"阻塞状态"与"等待状态"的区别是："阻塞状态"在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时间发生；而"等待状态"则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。
* **结束**：已终止线程的线程状态，线程已经结束执行。

